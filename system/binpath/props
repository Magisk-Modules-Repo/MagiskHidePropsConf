#!/system/bin/sh

# MagiskHide Props Config
# Copyright (c) 2018-2021 Didgeridoohan @ XDA Developers
# Licence: MIT

# ====================================================
# ==================== Root check ====================
# ====================================================

# Check for access to the Magisk internals. No access == no root
ls /data/adb>/dev/null 2>&1
if [ "$?" != 0 ]; then
	su -c props "$@" # Rerun script with root access
	exit
fi

# Startup message
echo ""
echo "Loading... Please wait."
echo ""

# =====================================================
# ================ Paths and variables ================
# =====================================================

ADBPATHPH=ADB_PLACEHOLDER
MODPATH=$ADBPATH/modules/MagiskHidePropsConf
LATEFILEPH=LATE_PLACEHOLDER
BOOTSTAGE="props"

# Development testing check
DEVTESTING=false
case "$1" in
	*t*) # Development testing
		DEVTESTING=true
	;;
esac

# Colours
if [ -f "$LATEFILE" ] && [ "$(grep "OPTIONCOLOUR=" $LATEFILE | sed 's|.*=||' | sed 's|\"||g')" == 0 ] || [ "$ANDROID_SOCKET_adbd" ]; then
	COLOURCHK="nc"
else
	COLOURCHK="$1"
fi
case "$COLOURCHK" in
	*nc*) # Don't use colours
		G=''
		R=''
		Y=''
		B=''
		V=''
		Bl=''
		C=''
		W=''
		N=''
	;;
	*)	# Use colours
		G='\e[01;32m'    # GREEN
		R='\e[01;31m'    # RED
		Y='\e[01;33m'    # YELLOW
		B='\e[01;34m'    # BLUE
		V='\e[01;35m'    # VIOLET
		Bl='\e[01;30m'   # BLACK
		C='\e[01;36m'    # CYAN
		W='\e[01;37m'    # WHITE
		N='\e[00;37;40m' # NEUTRAL
	;;
esac

# ===================================================
# ==================== Functions ====================
# ===================================================

# Load functions
. $MODPATH/common/util_functions.sh

if [ -f "$VLOGFILE" ]; then
		mv -f $VLOGFILE $VLASTLOGFILE
	fi
set -x 2>$VLOGFILE

log_handler "Running props script."

# Checking for Busybox
if [ ! -f "$BBPATH" ]; then
	menu_header "${C}No Busybox found${N}"
	echo ""
	echo "The script couldn't find Magisk's Busybox."
	echo "Make sure that your installation of Magisk"
	echo "is functioning properly and try again."
	echo ""
	echo "If you can't find anything wrong, please"
	echo "check the module documentation on how to"
	echo "ask for support and please provide"
	echo "logs (see the module documentation)."
	echo ""
	log_handler "No Busybox found."
	log_handler "Exiting... Bye bye.\n\n===================="
	exit 0
fi

# Check MagiskHide status
MHTEMP=$(magiskhide status) >> $LOGFILE 2>&1

blank_input() {
	# Find menu level
	case $1 in
		1)	INPUT=""
		;;
		2)	INPUT2=""
		;;
		3)	INPUT3=""
		;;
		4)	INPUT4=""
		;;
		5)	INPUT5=""
		;;
		6)	INPUT6=""
		;;
	esac

	echo ""
	echo -e "${R}Don't enter an empty value${N}."
	echo "Try again."
	sleep 2
}

active_option() {
	echo ""
	echo -e "${R}That's already the active option.${N}"
	sleep 2
}

invalid_input() {
	INPMSG=""

	# Set the message text
	case $1 in
		1) INPMSG="Only pick from the options above, one at a time."
		;;
		2) INPMSG="Only enter '${G}y${N}' or '${G}n${N}'."
		;;
		3) INPMSG="Only enter '${G}y${N}', '${G}n${N}' or '${G}e${N}'."
		;;
		4) INPMSG="Only enter '${G}y${N}', '${G}n${N}', '${G}r${N}' or '${G}e${N}'."
		;;
		5) INPMSG="Only enter '${G}d${N}', '${G}y${N}', '${G}n${N}' or '${G}e${N}'."
		;;
		6) INPMSG="Enter a fingerprint or pick from the options, one at a time."
		;;
		7) INPMSG="Only pick numbers, separated by a comma."
		;;
		8) INPMSG="Only enter numbers, or an option from above."
		;;
	esac

	# Find menu level
	case $2 in
		1) INPUT=""
		;;
		2) INPUT2=""
		;;
		3) INPUT3=""
		;;
		4) INPUT4=""
		;;
		5) INPUT5=""
		;;
		6) INPUT6=""
		;;
		7) INPUT7=""
		;;
	esac

	echo ""
	echo -e "${R}Invalid input${N}. $INPMSG"
	sleep 2
}

exit_fn() {
	menu_header "${C}Bye bye.${N}"
	echo ""
	log_handler "Exiting... Bye bye.\n\n===================="
	exit 0
}

# ======================== Device's fingerprint ========================
# Second menu level - fingerprint, $1=header, $2=Current fingerprint, $3=Original fingerprint, $4=Module set fingerprint
menu_change_fingerprint() {
	rm -f $CSTMFILE
	if [ "$DEVPRINTS" == "true" ]; then
		INPUT2=f
	else
		INPUT2=""
	fi
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Edit the device fingerprint to"
			echo "pass SafetyNet's CTS profile."
			echo
			if [ "$FINGERPRINTENB" == 0 ]; then
				echo "Fingerprint modification currently"
				echo "disabled because of a conflicting"
				echo "module (see the logs for details)."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
				INPUT=""
				break
			else
				if [ "$4" ] && [ "$PRINTEDIT" == 1 ]; then
					PRINTMODULETXT=" (by this module)"
				else
					PRINTMODULETXT=""
				fi
				if [ "$PRINTSTAGE" == 0 ]; then
					PRINTSTAGETXT="default"
				elif [ "$PRINTSTAGE" == 1 ]; then
					PRINTSTAGETXT="post-fs-data"
				elif [ "$PRINTSTAGE" == 2 ]; then
					PRINTSTAGETXT="late_start service"
				fi
				if [ "$PATCHSTAGE" == 0 ]; then
					PATCHSTAGETXT="default"
				elif [ "$PATCHSTAGE" == 1 ]; then
					PATCHSTAGETXT="post-fs-data"
				elif [ "$PATCHSTAGE" == 2 ]; then
					PATCHSTAGETXT="late_start service"
				fi
				if [ "$2" ]; then
					echo "Currently set to${PRINTMODULETXT}:"
					echo ""
					if [ "$PRINTMODULETXT" ]; then
						get_device_used "$2"
					fi
					echo -e ${C}$2${N}
					if [ "$2" != "$3" ]; then
						echo ""
						echo "The original value is:"
						echo -e ${C}$3${N}
					fi
				else
					echo "ro.build.fingerprint doesn't seem to"
					echo "currently exist on your system."
				fi
				echo ""
				echo "Enter the new fingerprint or"
				echo "pick from the options below."
				echo ""
				$(magiskhide status)
				echo ""
				echo -e "${G}f${N} - Pick a certified fingerprint"
				if [ "$PRINTMODULETXT" ]; then
					echo -e "${G}r${N} - Reset fingerprint"
				fi
				if [ "$ORIGVENDPRINT" ]; then
					if [ "$PRINTVEND" == 1 ]; then
						VENDTXT="${G} (active)${N}"
					else
						VENDTXT=""
					fi
					echo -e "${G}v${N} - Use vendor fingerprint (for Treble GSI ROMs)${VENDTXT}"
				fi
				if [ "$OPTIONWEBP" == 0 ]; then
					echo -e "${G}u${N} - Update fingerprints list (v$(get_file_value $PRINTSLOC "PRINTSV="))"
				fi
				echo -e "${G}s${N} - Boot stages (${C}${PRINTSTAGETXT}/${PATCHSTAGETXT}${N})."
				echo -e "${G}b${N} - Go back."
				echo -e "${G}e${N} - Exit"
				echo ""
				if [ "$PRINTCHK" == 1 ]; then
					echo -e "${R}The device fingerprint has been updated.${N}"
					echo -e "${R}Please reboot to apply.${N}"
					echo ""
				fi
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT2
			fi
		fi
		case "$INPUT2" in
			f|F)	menu_pick_print "$1"
			;;
			r|R)
				if [ "$PRINTMODULETXT" ]; then
					menu_reset_print "Reset fingerprint"
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
			v|V)
				if [ "$ORIGVENDPRINT" ]; then
					menu_vendor_print "$1"
				else
					invalid_input 6 2
				fi
			;;
			u|U)
				if [ "$OPTIONWEBP" == 0 ]; then
					menu_update_print "Update fingerprints list"
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
			s|S) menu_bootstage_print "$1"
			;;
			b|B)
				INPUT=""
				break
			;;
			e|E) exit_fn
			;;
			""|[[:blank:]]*)	blank_input 2
			;;
			*)
				if [ "${#INPUT2}" -lt 10 ]; then
					invalid_input 6 2
				else
					menu_new_print "$1" "$INPUT2" 2
				fi
			;;
		esac
	done
}

# Third menu level - pick fingerprint, $1=header
menu_pick_print() {
	DEVPRINTS="" # Disable automatically entering the fingerprints list after the first time.
	INPUT3=""
	OEMLIST=""
	HEADERPRINTV="${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")\n Select an option below."
	while true
	do
		if [ -z "$INPUT3" ]; then
			# Load the list of fingerprint files
			log_handler "Loading fingerprints list v$(get_file_value $PRINTSLOC "PRINTSV=")."
			OEMLIST="$(ls $PRINTFILES | sed 's|\.sh||g')"
			if [ "$OEMLIST" ]; then
				# Check for custom fingerprints list
				if [ -s "$CSTMPRINTS" ] && [ ! -f "$CSTMFILE" ]; then
					log_handler "Found custom fingerprints list."
					format_file $CSTMPRINTS
					log_handler "Creating custom prints file."
					cat $CSTMPRINTS >> $LOGFILE 2>&1 && echo "" >> $LOGFILE 2>&1
					echo -e "PRINTSLIST=\"" >> $CSTMFILE
					cat $CSTMPRINTS >> $CSTMFILE
					echo -e "\"" >> $CSTMFILE
					# Reload the list with new files
					OEMLIST="$(ls $PRINTFILES | sed 's|\.sh||g')"
				fi
				ITEMCOUNT=1
				menu_header "$HEADERPRINTV"
				echo ""
				# Display currently set print when fingerprints testing
				if [ "$(get_file_value $PRINTSLOC "PRINTSV=")" == "Dev" ]; then
					TMPDEVPRINT="$(getprop ro.build.fingerprint)"
					echo "Currently set to:"
					get_device_used $TMPDEVPRINT
					echo -e "${C}$TMPDEVPRINT${N}"
					echo ""
				fi
				for ITEM in $OEMLIST; do
					echo -e "${G}$ITEMCOUNT${N} - $ITEM"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				done
				echo -e "${G}b${N} - Go back"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT3
			else
				log_handler "No fingerprints list."
				collect_logs "issue"
				menu_header "${C}$1${N}\n Something's wrong!"
				echo "Hm... That's not right."
				echo ""
				echo "There is currently no fingerprints list"
				echo "available. Try updating it manually."
				echo ""
				echo "If the issue persists, report it in the"
				echo -e "support thread @ XDA, ${R}with logs!${C}"
				echo ""
				echo "Logs have automatically been saved to"
				echo -e "your internal storage ${R}(propslogs.tar.gz)${C}."
				echo ""
				echo -n "Press enter to continue..."
				read -r INPUTTMP
				INPUT2=""
				break
			fi
		fi
		case "$INPUT3" in
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT3" -ge 1 -a "$INPUT3" -lt "$ITEMCOUNT" ]; then
					ITEMCOUNT=1
					for ITEM in $OEMLIST; do
						if [ "$ITEMCOUNT" == "$INPUT3" ]; then
							menu_pick_print_sub "$HEADERPRINTV" "$ITEM"
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				else
					invalid_input 1 3
				fi
			;;
		esac
	done
}

# Fourth menu level - pick fingerprint, $1=header, $2=OEM
menu_pick_print_sub() {
	# Loading fingerprints
	TMPFILE=$PRINTFILES/$2.sh
	if [ -f "$TMPFILE" ]; then
		. $TMPFILE
		INPUT4=""
	else
		menu_header "$1"
		log_handler "Can't find '$TMPFILE'."
		collect_logs "issue"
		echo "Oh no! Something went wrong..."
		echo ""
		echo "Can't find the fingerprints file."
		echo "Try updating it manually."
		echo ""
		echo "If the issue persists, report it in the"
		echo -e "support thread @ XDA, ${R}with logs!${C}"
		echo ""
		echo "Logs have automatically been saved to"
		echo -e "your internal storage ${R}(propslogs.tar.gz)${C}."
		echo ""
		echo -n "Press enter to continue..."
		read -r INPUTTMP
		INPUT4="b"
	fi
	while true
	do
		if [ -z "$INPUT4" ]; then
			ITEMCOUNT=1
			menu_header "$1"
			echo ""
			# Display currently set print when fingerprints testing
			if [ "$(get_file_value $PRINTSLOC "PRINTSV=")" == "Dev" ]; then
				TMPDEVPRINT="$(getprop ro.build.fingerprint)"
				echo "Currently set to:"
				get_device_used $TMPDEVPRINT
				echo -e "${C}$TMPDEVPRINT${N}"
				echo ""
			fi
			SAVEIFS=$IFS
			IFS=$(echo -en "\n\b")
			for ITEM in $PRINTSLIST; do
				if [ "$(get_first $ITEM)" == "$2" ] || [ "$2" == "Custom" ]; then
					echo -e "${G}$ITEMCOUNT${N} - $(get_device "$ITEM")"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				fi
			done
			IFS=$SAVEIFS
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			b|B)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT4" -ge 1 -a "$INPUT4" -lt "$ITEMCOUNT" ]; then
					ITEMCOUNT=1
					SAVEIFS=$IFS
					IFS=$(echo -en "\n\b")
					for ITEM in $PRINTSLIST; do
						if [ "$ITEMCOUNT" == "$INPUT4" ]; then
							case "$ITEM" in
								*\;*)
									IFS=$SAVEIFS
									menu_pick_print_version "$1" "$(get_device "$ITEM")" "$(get_eq_right "$ITEM")"
									INPUT2=""
									INPUT3=""
									break
								;;
								*)
									IFS=$SAVEIFS
									menu_new_print "$1" "$(get_eq_right "$ITEM")"
									INPUT2=""
									INPUT3=""
									break
								;;
							esac
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
					IFS=$SAVEIFS
				else
					invalid_input 1 4
				fi
			;;
		esac
	done
}

# Fifth menu level - pick Android version, $1=header, $2=Device, $3=fingerprint string (without device info)
menu_pick_print_version() {
	INPUT5=""
	ANDROIDV="$(get_print_versions "$2")"
	while true
	do
		if [ -z "$INPUT5" ]; then
			ITEMCOUNT=1
			menu_header "$1"
			echo ""
			echo "There are several fingerprints available"
			echo "for this device, for different versions"
			echo "of Android. Pick one."
			echo ""
			echo -e "${C}$(echo "$2" | sed 's| (.*||')${N}"
			echo ""
			for ITEM in $ANDROIDV; do
				echo -e "${G}$ITEMCOUNT${N} - Android version ${C}$ITEM${N}"
				ITEMCOUNT=$(($ITEMCOUNT+1))
			done
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT5
		fi
		case "$INPUT5" in
			b|B)
				INPUT4=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT5" -ge 1 -a "$INPUT5" -lt "$ITEMCOUNT" ]; then
					ITEMCOUNT=1
					for ITEM in $ANDROIDV; do
						if [ "$ITEMCOUNT" == "$INPUT5" ]; then
							TMPPRINT="$(echo $3 | cut -f $ITEMCOUNT -d ';')"
							menu_new_print "$1" "$TMPPRINT"
							INPUT2=""
							INPUT3=""
							INPUT4=""
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				else
					invalid_input 1 5
				fi
			;;
		esac
	done
}

# Sixth menu level - confirm fingerprint, $1=header, $2=fingerprint
menu_new_print() {
	# Check if fingerprints testing is active
	if [ "$(get_file_value $PRINTSLOC "PRINTSV=")" == "Dev" ]; then
		DEVCHK=true
		INPUT6=y
	else
		DEVCHK=false
		INPUT6=""
	fi
	while true
	do
		if [ -z "$INPUT6" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "You are about to use the following as your device's fingerprint."
			echo ""
			get_device_used "$2"
			echo -e "${V}$(get_print_display $2)${N}"
			echo ""
			echo "Make sure that it is correct before continuing."
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT6
		fi
		case "$INPUT6" in
			y|Y)
				change_print "$1" "$2"
				if [ "$DEVCHK" == "true" ]; then
					force_reboot
				fi
				INPUT2=""
				INPUT3=""
				INPUT4=""
				INPUT5=""
				break
			;;
			n|N)
				INPUT2=""
				INPUT3=""
				INPUT4=""
				INPUT5=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 6
			;;
		esac
	done
}

# Third menu level - Reset fingerprint, $1=header
menu_reset_print() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset the device"
			echo "fingerprint to the default value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_print "$1"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Vendor fingerprint, $1=header
menu_vendor_print() {
	INPUT3=""
	while true
	do
		if [ "$PRINTVEND" == 0 ]; then
			STATETXT="${G}enable${N}"
			CURRTXT="${R}disabled${N}"
			TMPVAL=1
		else
			STATETXT="${R}disable${N}"
			CURRTXT="${G}enabled${N}"
			TMPVAL=0
		fi
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo -e "This will $STATETXT using the vendor"
			echo "fingerprint for Treble GSI ROMs."
			echo ""
			echo -e "The option is currently $CURRTXT."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				change_print_vendor "$1" "$TMPVAL"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Update fingerprints listj, $1=header
menu_update_print() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")"
			echo ""
			echo "Do you want to check online if there"
			echo "is an update to the fingerprints list?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				download_prints "manual"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Boot stage, $1=header
menu_bootstage_print() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$PRINTSTAGE" == 0 ]; then
				PRINTSTAGETXT=" ${C}(default)${N}"
			elif [ "$PRINTSTAGE" == 1 ]; then
				PRINTSTAGETXT=" ${C}(post-fs-data)${N}"
			elif [ "$PRINTSTAGE" == 2 ]; then
				PRINTSTAGETXT=" ${C}(late_start service)${N}"
			fi
			if [ "$PATCHSTAGE" == 0 ]; then
				PATCHSTAGETXT=" ${C}(default)${N}"
			elif [ "$PATCHSTAGE" == 1 ]; then
				PATCHSTAGETXT=" ${C}(post-fs-data)${N}"
			elif [ "$PATCHSTAGE" == 2 ]; then
				PATCHSTAGETXT=" ${C}(late_start service)${N}"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Change boot stage for the device fingerprint"
			echo "or security patch date props."
			echo ""
			echo "Pick an option below."
			echo ""
			echo -e "${G}1${N} - Device fingerprint$PRINTSTAGETXT."
			echo -e "${G}2${N} - Security patch date$PATCHSTAGETXT."
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			1)
				menu_bootstage_print_set "$1" "print"
				INPUT2=""
				break
			;;
			2)
				menu_bootstage_print_set "$1" "patch"
				INPUT2=""
				break
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 3
			;;
		esac
	done
}

# Fourth menu level - Set boot stage, $1=header, $2=type (print or patch)
menu_bootstage_print_set() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			if [ "$2" == "print" ]; then
				PROPTXT="fingerprint"
				TMPSTAGE=$PRINTSTAGE
				CHNGSTAGE="PRINTSTAGE"
			elif [ "$2" == "patch" ]; then
				PROPTXT="security patch date"
				TMPSTAGE=$PATCHSTAGE
				CHNGSTAGE="PATCHSTAGE"
			fi
			if [ "$TMPSTAGE" == 0 ]; then
				CURRTXT="default"
				TMPTXT="${C}post-fs-data${N} or ${C}late_start sevice${N}"
				CHOICETXT="${G}p${N}(ost), ${G}l${N}(ate)"
			elif [ "$TMPSTAGE" == 1 ]; then
				CURRTXT="post-fs-data"
				TMPTXT="${C}default${N} or ${C}late_start service${N}"
				CHOICETXT="${G}d${N}(efault), ${G}l${N}(ate)"
			elif [ "$TMPSTAGE" == 2 ]; then
				CURRTXT="late_start service"
				TMPTXT="${C}default${N} or ${C}post-fs-data${N}"
				CHOICETXT="${G}d${N}(efault), ${G}p${N}(post)"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Current boot stage for $PROPTXT is"
			echo -e "${G}$CURRTXT${N}."
			echo ""
			echo "Do you want to change it to"
			echo -e "$TMPTXT?"
			echo ""
			echo -en "Enter $CHOICETXT, ${G}b${N}(ack) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			d|D)
				if [ "$TMPSTAGE" != 0 ]; then
					before_change
					OPTNEW=0
					log_handler "Boot stage for $PROPTXT changed to default."
					replace_fn $CHNGSTAGE $TMPSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT3=""
					after_change "$1"
					break
				else
					invalid_input 1 4
				fi
			;;
			p|P)
				if [ "$TMPSTAGE" != 1 ]; then
					before_change
					OPTNEW=1
					log_handler "Boot stage for $PROPTXT changed to post-fs-data."
					replace_fn $CHNGSTAGE $TMPSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT3=""
					after_change "$1"
					break
				else
					invalid_input 1 4
				fi
			;;
			l|L)
				if [ "$TMPSTAGE" != 2 ]; then
					before_change
					OPTNEW=2
					log_handler "Boot stage for $PROPTXT changed to late_start service."
					replace_fn $CHNGSTAGE $TMPSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT3=""
					after_change "$1"
					break
				else
					invalid_input 1 4
				fi
			;;
			b|B)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 4
			;;
		esac
	done
}

# ======================== Force BASIC key attestation ========================
# Second menu level - BASIC attestation, $1=header
menu_force_basic() {
	INPUT2=""
	while true
	do
		if [ "$BASICATTEST" == 0 ]; then
			fn_oem_file # Find the OEM print file used
			STATETXT="${G}enable${N}"
			if [ "$BASICATTMODEL" ]; then
				YTXT=", use default value (${C}$BASICATTMODEL${N})"
			else
				YTXT=", use default value (${C}$(getprop ro.product.device)${N})"
			fi
			YDTXT="Yes, p"
		else
			STATETXT="${R}disable${N}"
			YTXT=""
			YDTXT="P"
		fi
		if [ "$BASICATTCUST" ]; then
			CUSTTXT=" (${G}active${N})"
		else
			CUSTTXT=""
		fi
		if [ "$BASICATTLIST" ]; then
			LISTTXT=" (${G}active${N})"
		else
			LISTTXT=""
		fi
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Edit device model to change"
			echo "bootloader state check from"
			echo "hardware based to basic."
			echo ""
			echo -e "Do you want to $STATETXT"
			echo "forced BASIC key attestation?"
			echo ""
			echo "The currently loaded value is:"
			echo -e "${C}$(getprop ro.product.model)${N}"
			if [ "$BASICATTEST" == 1 ] && [ "$ORIGMODEL" != "$(getprop ro.product.model)" ]; then
				echo "(Set by this module.)"
			fi
			echo ""
			echo -e "${G}y${N} - Yes$YTXT"
			echo -e "${G}d${N} - ${YDTXT}ick value from device list$LISTTXT"
			echo -e "${G}c${N} - Set a custom value$CUSTTXT"
			echo -e "${G}n${N} - No"
			if [ "$BASICATTCUST" ] || [ "$BASICATTLIST" ]; then
				echo -e "${G}r${N} - Reset"
			fi
			echo -e "${G}e${N} - Exit"
			echo ""
			if [ "$BASICATTEST" == 0 ]; then
				echo "This may disable some device"
				echo "specific features, like the"
				echo "Samsung Galaxy Store. YMMV."
				echo ""
			fi
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)
				forced_basic "$1"
				INPUT=""
			;;
			n|N)
				INPUT=""
				break
			;;
			d|D)
				forced_list_menu "$1"
				INPUT=""
			;;
			c|C)
				forced_custom_menu "$1"
				INPUT=""
			;;
			r|R)
				if [ "$BASICATTCUST" ] || [ "$BASICATTLIST" ]; then
					forced_reset_menu "$1"
					INPUT=""
					break
				else
					invalid_input 1 2
				fi
			;;
			e|E) exit_fn
			;;
			*) invalid_input 1 2
			;;
		esac
	done
}

# Third menu level - Pick from list, $1=header
forced_list_menu() {
	INPUT3=""
	OEMLIST=""
	HEADERPRINTV="${C}$1${N}\n List version - v$(get_file_value $PRINTSLOC "PRINTSV=")\n Select an option below."
	while true
	do
		if [ -z "$INPUT3" ]; then
			# Load the list of fingerprint files
			log_handler "Loading fingerprints list v$(get_file_value $PRINTSLOC "PRINTSV=")."
			OEMLIST="$(ls $PRINTFILES | sed 's|\.sh||g')"
			if [ "$OEMLIST" ]; then
				ITEMCOUNT=1
				menu_header "$HEADERPRINTV"
				echo ""
				for ITEM in $OEMLIST; do
					echo -e "${G}$ITEMCOUNT${N} - $ITEM"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				done
				echo ""
				if [ "$BASICATTLIST" ]; then
					echo "The currently set list value is:"
					echo -e "${C}$BASICATTLIST${N}"
					echo ""
					echo -e "${G}r${N} - Reset list value"
				else
					echo "Currently the default/custom"
					echo "values are being used."
					echo ""
				fi
				echo -e "${G}b${N} - Go back"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo "Do NOT use your actual device."
				echo "Pick a device as close to yours"
				echo "as you can, to possibly keep"
				echo "device specific features working."
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT3
			else
				log_handler "No fingerprints list."
				collect_logs "issue"
				menu_header "${C}$1${N}\n Something's wrong!"
				echo "Hm... That's not right."
				echo ""
				echo "There is currently no fingerprints list"
				echo "available. Try updating it manually."
				echo ""
				echo "If the issue persists, report it in the"
				echo -e "support thread @ XDA, ${R}with logs!${C}"
				echo ""
				echo "Logs have automatically been saved to"
				echo -e "your internal storage ${R}(propslogs.tar.gz)${C}."
				echo ""
				echo -n "Press enter to continue..."
				read -r INPUTTMP
				INPUT2=""
				break
			fi
		fi
		case "$INPUT3" in
			r|R)
				if [ "$BASICATTLIST" ]; then
					forced_list_reset_menu "$1"
					INPUT2=""
					break
				else
					invalid_input 1 3
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT3" -ge 1 -a "$INPUT3" -lt "$ITEMCOUNT" ]; then
					ITEMCOUNT=1
					for ITEM in $OEMLIST; do
						if [ "$ITEMCOUNT" == "$INPUT3" ]; then
							forced_list_pick_menu "$HEADERPRINTV" "$ITEM"
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				else
					invalid_input 1 3
				fi
			;;
		esac
	done
}

# Fourth menu level - reset list value, $1=header
forced_list_reset_menu() {
	INPUT4=""
	fn_oem_file # Find the OEM print file used
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Are you sure you want to reset"
			echo "the list value for forced BASIC"
			echo "key attestation to the default"
			if [ "$BASICATTMODEL" ]; then
				echo -e "value (${C}$BASICATTMODEL${N})?"
			else
				echo -e "value (${C}$(getprop ro.product.device)${N})?"
			fi
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				forced_reset "$1" 1
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*) invalid_input 3 4
			;;
		esac
	done
}

# Fourth menu level - pick from list, $1=header, $2=OEM
forced_list_pick_menu() {
	# Loading fingerprints
	TMPFILE=$PRINTFILES/$2.sh
	if [ -f "$TMPFILE" ]; then
		. $TMPFILE
		INPUT4=""
	else
		menu_header "$1"
		log_handler "Can't find '$TMPFILE'."
		collect_logs "issue"
		echo "Oh no! Something went wrong..."
		echo ""
		echo "Can't find the fingerprints file."
		echo "Try updating it manually."
		echo ""
		echo "If the issue persists, report it in the"
		echo -e "support thread @ XDA, ${R}with logs!${C}"
		echo ""
		echo "Logs have automatically been saved to"
		echo -e "your internal storage ${R}(propslogs.tar.gz)${C}."
		echo ""
		echo -n "Press enter to continue..."
		read -r INPUTTMP
		INPUT4="b"
	fi
	while true
	do
		if [ -z "$INPUT4" ]; then
			ITEMCOUNT=1
			menu_header "$1"
			echo ""
			SAVEIFS=$IFS
			IFS=$(echo -en "\n\b")
			for ITEM in $PRINTSLIST; do
				if [ "$(get_first $ITEM)" == "$2" ]; then
					echo -e "${G}$ITEMCOUNT${N} - $(get_device "$ITEM" | sed "s| (.*)||")"
					ITEMCOUNT=$(($ITEMCOUNT+1))
				fi
			done
			IFS=$SAVEIFS
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			b|B)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT4" -ge 1 -a "$INPUT4" -lt "$ITEMCOUNT" ]; then
					ITEMCOUNT=1
					SAVEIFS=$IFS
					IFS=$(echo -en "\n\b")
					for ITEM in $PRINTSLIST; do
						if [ "$ITEMCOUNT" == "$INPUT4" ]; then
							IFS=$SAVEIFS
							forced_list_confirm_menu "$1" "$(get_eq_left "$ITEM" | sed "s|^.*\:||")"
							INPUT2=""
							INPUT3=""
							break
						fi
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
					IFS=$SAVEIFS
				else
					invalid_input 1 4
				fi
			;;
		esac
	done
}

# Fifth menu level - confirm list value, $1=header, $2=device info
forced_list_confirm_menu() {
	INPUT5=""
	while true
	do
		if [ -z "$INPUT5" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Do you want to use the following"
			echo "as the value for the module props?"
			echo ""
			echo -e "${C}$2${N}"
			echo ""
			if [ "$BASICATTLIST" ]; then
				echo "The currently set list value is:"
				echo -e "${C}$BASICATTLIST${N}"
			else
				echo "Currently the default/custom"
				echo "values are being used."
			fi
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT5
		fi
		case "$INPUT5" in
			y|Y)
				forced_list_confirm "$1" "$2"
				INPUT2=""
				INPUT3=""
				INPUT4=""
				break
			;;
			n|N)
				INPUT4=""
				break
			;;
			e|E) exit_fn
			;;
			*) invalid_input 3 5
			;;
		esac
	done
}

# Third menu level - set custom value, $1=header
forced_custom_menu() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the value you want the"
			echo "module props to have, or pick"
			echo "an option below."
			echo ""
			if [ "$BASICATTCUST" ]; then
				echo "The currently set custom value is:"
				echo -e "${C}$BASICATTCUST${N}"
				echo ""
				echo -e "${G}r${N} - Reset custom value"
			else
				echo "Currently the default/list"
				echo "values are being used."
				echo ""
			fi
			echo -e "${G}b${N} - Back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			r|R)
				if [ "$BASICATTCUST" ]; then
					forced_custom_reset_menu "$1"
					INPUT2=""
					break
				else
					invalid_input 1 3
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*) forced_custom_confirm_menu "$1" "$INPUT3"
			;;
		esac
	done
}

# Fourth menu level - reset custom value, $1=header
forced_custom_reset_menu() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Are you sure you want to reset"
			echo "the custom value for forced BASIC"
			echo "key attestation to the default"
			if [ "$BASICATTMODEL" ]; then
				echo -e "value (${C}$BASICATTMODEL${N})?"
			else
				echo -e "value (${C}$(getprop ro.product.device)${N})?"
			fi
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				forced_reset "$1" 2
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*) invalid_input 3 4
			;;
		esac
	done
}

# Fourth menu level - confirm custom value, $1=header, $2=custom input value
forced_custom_confirm_menu() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Do you want to use the following"
			echo "as the value for the module props?"
			echo ""
			echo -e "${C}$2${N}"
			echo ""
			if [ "$BASICATTCUST" ]; then
				echo "The currently set custom value is:"
				echo -e "${C}$BASICATTCUST${N}"
			else
				echo "Currently the default module"
				echo "values are being used."
			fi
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				forced_custom_confirm "$1" "$2"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*) invalid_input 3 4
			;;
		esac
	done
}

# Third menu level - reset, $1=header
forced_reset_menu() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Are you sure you want to reset"
			echo "the custom/list value for forced"
			echo "BASIC key attestation to the default."
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				forced_reset "$1" 3
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*) invalid_input 3 3
			;;
		esac
	done
}

# ======================== Device simulation ========================
# Second menu level - Device simulation, $1=header
menu_dev_sim() {
	INPUT2=""
	while true
	do
		ENABLE="${G} (enabled)${N}"
		DISABLE="${R} (disabled)${N}"
		DEVSIMTXT=""
		DESCRIPTIONTXT=""
		DISPTXT=""
		SDKTXT=""
		MANUFACTURERTXT=""
		MODELTXT=""
		if [ "$DEVSIM" == 1 ]; then
			DEVSIMTXT=$ENABLE
		else
			DEVSIMTXT=$DISABLE
		fi
		for ITEM in $PRINTPARTS; do
			TMPPROP=$(get_prop_type $ITEM | tr '[:lower:]' '[:upper:]')
			TMPVAR=$(echo "${TMPPROP}TXT")
			if [ "$(get_file_value $LATEFILE "${TMPPROP}SET=")" == 1 ]; then
				eval "${TMPPROP}TXT='$ENABLE'"
			elif [ "$(get_file_value $LATEFILE "${TMPPROP}SET=")" == 0 ]; then
				eval "${TMPPROP}TXT='$DISABLE'"
			else
				eval "${TMPPROP}TXT="
			fi
		done
		if [ "$DESCRIPTIONSET" == 1 ]; then
			DESCRIPTIONTXT=$ENABLE
		else
			DESCRIPTIONTXT=$DISABLE
		fi
		if [ "$DISPLAYSET" == 1 ]; then
			DISPTXT=$ENABLE
		else
			DISPTXT=$DISABLE
		fi
		if [ "$SDKSET" == 1 ]; then
			SDKTXT=$ENABLE
		else
			SDKTXT=$DISABLE
		fi
		if [ "$MANUFACTURERSET" == 1 ]; then
			MANUFACTURERTXT=$ENABLE
		else
			MANUFACTURERTXT=$DISABLE
		fi
		if [ "$MODELSET" == 1 ]; then
			MODELTXT=$ENABLE
		else
			MODELTXT=$DISABLE
		fi
		if [ "$PARTPROPSSET" == 1 ]; then
			PARTPROPSTXT=$ENABLE
		else
			PARTPROPSTXT=$DISABLE
		fi
		if [ "$SIMSTAGE" == 0 ]; then
			STAGETXT=" ${C}(default)${N}"
		elif [ "$SIMSTAGE" == 1 ]; then
			STAGETXT=" ${C}(post-fs-data)${N}"
		elif [ "$SIMSTAGE" == 2 ]; then
			STAGETXT=" ${C}(late_start service)${N}"
		fi
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Change prop values based on the"
			echo "currently used fingerprint to"
			echo "simulate that device."
			echo ""
			if [ "$PRINTEDIT" == 0 ]; then
				echo "This option is only enabled if there"
				echo "is a fingerprint set by the module."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
				INPUT=""
				break
			fi
			echo "These settings will do basic device"
			echo "simulation by setting certain props"
			echo "based on the currently set device"
			echo "fingerprint."
			echo ""
			echo -e "${R}Only enable this if you really need it"
			echo "and be careful about which props you"
			echo -e "enable.${N}"
			echo ""
			echo "Pick an option below."
			echo ""
			echo -e "${G} s${N} - Device simulation${DEVSIMTXT}"
			if [ "$DEVSIM" == 1 ]; then
				echo -e "${G} 1${N} - ro.product.brand${BRANDTXT}"
				echo -e "${G} 2${N} - ro.product.name${NAMETXT}"
				echo -e "${G} 3${N} - ro.product.device${DEVICETXT}"
				echo -e "${G} 4${N} - ro.build.version.release${RELEASETXT}"
				echo -e "${G} 5${N} - ro.build.id${IDTXT}"
				echo -e "${G} 6${N} - ro.build.version.incremental${INCREMENTALTXT}"
				echo -e "${G} 7${N} - ro.build.version.sdk${SDKTXT}"
				echo -e "${G} 8${N} - ro.build.display.id${DISPTXT}"
				if [ "$SIMMANUFACTURER" ] && [ "$SIMMODEL" ]; then
					echo -e "${G} 9${N} - ro.product.manufacturer${MANUFACTURERTXT}"
					if [ "$BASICATTEST" == 0 ]; then
						echo -e "${G}10${N} - ro.product.model${MODELTXT}"
					else
						echo -e "    (Simulating ro.product.model is currently ${R}disabled${N}.)"
						echo ""
					fi
					MANMODEN=true
				else
					MANMODEN=false
				fi
				echo -e "${G} a${N} - Enable/disable all props"
			fi
			echo -e "${G} d${N} - ro.build.description${DESCRIPTIONTXT}"
			echo -e "${G} p${N} - Use partition props$PARTPROPSTXT"
			echo -e "${G} t${N} - Boot stage$STAGETXT"
			echo -e "${G} b${N} - Go back"
			echo -e "${G} e${N} - Exit"
			echo ""
			echo "Pick several options at once by"
			echo "separating inputs with a comma."
			echo "Example: 1,5,6"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT2
		fi
		case "$INPUT2" in
			s|S) menu_dev_sim_enable "$1"
			;;
			*\,*|1|2|3|4|5|6|7|8|9|10|a|A|d|D)
				case "$INPUT2" in
					*\,*)
						NUMCHECK="$(echo $(echo $INPUT2 | sed 's|\,||g') | tr -d [0-9])"
						case "$INPUT2" in
							*1*|*2*|*3*|*4*|*5*|*6*|*7*|*8*|*a*|*A*|*d*|*D*)
								if [ -z "$NUMCHECK" ]; then
									menu_dev_sim_prop "$1" "$INPUT2"
								else
									invalid_input 7 2
								fi
							;;
							*9*|*10*)
								if [ "$MANMODEN" == "false" ]; then
									invalid_input 1 2
								else
									if [ "$BASICATTEST" == 1 ]; then
										case "$INPUT2" in
											*10*) invalid_input 7 2
											;;
											*)
												if [ -z "$NUMCHECK" ]; then
													menu_dev_sim_prop "$1" "$INPUT2"
												else
													invalid_input 7 2
												fi
											;;
										esac
									else
										if [ -z "$NUMCHECK" ]; then
											menu_dev_sim_prop "$1" "$INPUT2"
										else
											invalid_input 7 2
										fi
									fi
								fi
							;;
							*)
								invalid_input 1 2
							;;
						esac
					;;
					*)
						if [ "$DEVSIM" == 1 ] || [ "$INPUT2" == "d" -o "$INPUT2" == "D" ]; then
							if [ "$MANMODEN" == "false" ] && [ "$INPUT2" == 9 -o "$INPUT2" == 10 ]; then
								invalid_input 1 2
							else
								if [ "$BASICATTEST" == 1 ] && [ "$INPUT2" == 10 ]; then
									invalid_input 1 2
								else
									menu_dev_sim_prop "$1" "$INPUT2"
								fi
							fi
						else
							invalid_input 1 2
						fi
					;;
				esac
			;;
			t|T) menu_bootstage_sim "$1"
			;;
			p|P) menu_partprops_sim "$1" "$PARTPROPSSET"
			;;
			b|B)
				INPUT=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# Third menu level - Enable device simulation, $1=header
menu_dev_sim_enable() {
	INPUT3=""
	while true
	do
		if [ "$DEVSIM" == 0 ]; then
			STATETXT="${G}enable${N}"
			CURRTXT="${R}disabled${N}"
		else
			STATETXT="${R}disable${N}"
			CURRTXT="${G}enabled${N}"
		fi
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo -e "Do you want to $STATETXT basic"
			echo "device simulation?"
			echo ""
			echo -e "Currently $CURRTXT."
			echo ""
			if [ "$DEVSIM" == 0 ]; then
				echo "Enabling this option will let you"
				echo "set certain props based on the"
				echo "currently used device fingerprint."
				echo ""
			fi
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				change_dev_sim "$1" "file"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Set device simulation props, $1=header, $2=list value for specific prop/option
menu_dev_sim_prop() {
	INPUT3=""
	while true
	do
		TMPTXT=""
		TMPPARTS=$PRINTPARTS$ADNSIMPROPS1$ADNSIMPROPS2
		TMPITEMS=""
		CNT=1
		case "$2" in
			*\,*) TMPTXT="Multi"
			;;
			1) TMPTXT="ro.build.brand"
			;;
			2) TMPTXT="ro.build.name"
			;;
			3) TMPTXT="ro.build.device"
			;;
			4) TMPTXT="ro.build.version.release"
			;;
			5) TMPTXT="ro.build.id"
			;;
			6) TMPTXT="ro.build.version.incremental"
			;;
			7) TMPTXT="ro.build.version.sdk"
			;;
			8) TMPTXT="ro.build.display.id"
			;;
			9) TMPTXT="ro.product.manufacturer"
			;;
			10) TMPTXT="ro.product.model"
			;;
			a|A) TMPTXT="All"
			;;
			d|D) TMPTXT="ro.build.description"
			;;
		esac
		if [ "$TMPTXT" == "Multi" ] || [ "$TMPTXT" == "All" ]; then
			TMPLST=$(echo $2 | sed 's|\,| |g')
			for ITEM in $TMPPARTS; do
				for INT in $TMPLST; do
					if [ "$INT" == "$CNT" ]; then
						if [ "$TMPITEMS" ]; then
							TMPITEMS="$TMPITEMS $ITEM"
						else
							TMPITEMS="$ITEM"
						fi
					fi
				done
				CNT=$(($CNT+1))
			done
			if [ "$TMPTXT" == "All" ]; then
				TYPETXT="all"
				if [ "$MANMODEN" == "true" ]; then
					TMPINPUT="$TMPPARTS"
				else
					TMPINPUT=$PRINTPARTS$ADNSIMPROPS1
				fi
			else
				TYPETXT="the following"
				TMPINPUT="$TMPITEMS"
			fi
			if [ -z "$INPUT3" ]; then
				menu_header "${C}$1${N}"
				echo ""
				echo -e "Do you want to ${G}enable${N} or ${R}disable${N}"
				echo "$TYPETXT simulation props?"
				echo ""
				if [ "$TMPTXT" == "Multi" ]; then
					echo "${C}$(echo $TMPITEMS | sed 's| |\n|g')${N}"
					echo ""
				fi
				echo -e "${R}Warning!${N} Some of these props"
				echo "may cause issues with your device."
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -e "${G}1${N} - Enable"
				echo -e "${G}2${N} - Disable"
				echo -e "${G}b${N} - Go back"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT3
				case "$INPUT3" in
					1|2)
						before_change
						if [ "$INPUT3" == 1 ]; then
							TMPVAL=1
						else
							TMPVAL=0
						fi
						for ITEM in $TMPINPUT; do
							change_sim_prop "Device simulation" "$ITEM" "$TMPVAL" "none"
						done
						INPUT2=""
						after_change "$1"
						break
					;;
					b|B)
						INPUT2=""
						break
					;;
					e|E) exit_fn
					;;
					*)	invalid_input 1 3
					;;
				esac
			fi
		else
			TMPPROP=$(get_prop_type $TMPTXT | tr '[:lower:]' '[:upper:]')
			if [ "$(get_file_value $LATEFILE "${TMPPROP}SET=")" == 0 ]; then
				STATETXT="${G}enable${N}"
				CURRTXT="${R}disabled${N}"
				TMPVAL=1
			else
				STATETXT="${R}disable${N}"
				CURRTXT="${G}enabled${N}"
				TMPVAL=0
			fi
			if [ -z "$INPUT3" ]; then
				menu_header "${C}$1${N}"
				echo ""
				echo -e "Do you want to $STATETXT simulating"
				echo -e "${C}${TMPTXT}${N}?"
				echo -e "It is currently $CURRTXT."
				echo ""
				echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
				read -r INPUT3
				case "$INPUT3" in
					y|Y)
						if [ "$TMPPROP" == "DESCRIPTION" ]; then
							change_sim_descr "$1" "$TMPVAL"
						else
							change_sim_prop "$1" "$TMPTXT" "$TMPVAL"
						fi
						INPUT2=""
						break
					;;
					n|N)
						INPUT2=""
						break
					;;
					e|E) exit_fn
					;;
					*)	invalid_input 3 3
					;;
				esac
			fi
		fi
	done
}

# Third menu level - Partition props, $1=header, $2=Partition simulation currently enabled or disabled
menu_partprops_sim() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "1" ]; then
				CURRTXT="enabled"
				TMPTXT="disable"
				OPTCURR=1
				OPTNEW=0
			else
				CURRTXT="disabled"
				TMPTXT="enable"
				OPTCURR=0
				OPTNEW=1
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo "Partition specific props simulation"
			echo -e "is currently ${G}$CURRTXT${N}."
			echo ""
			echo -e "Do you want to ${C}$TMPTXT${N} it?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				change_sim_partprops "$1" "$OPTNEW"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Boot stage, $1=header
menu_bootstage_sim() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$SIMSTAGE" == 0 ]; then
				CURRTXT="default"
				TMPTXT="${C}post-fs-data${N} or ${C}late_start sevice${N}"
				CHOICETXT="${G}p${N}(ost), ${G}l${N}(ate)"
			elif [ "$SIMSTAGE" == 1 ]; then
				CURRTXT="post-fs-data"
				TMPTXT="${C}default${N} or ${C}late_start service${N}"
				CHOICETXT="${G}d${N}(efault), ${G}l${N}(ate)"
			elif [ "$SIMSTAGE" == 2 ]; then
				CURRTXT="late_start service"
				TMPTXT="${C}default${N} or ${C}post-fs-data${N}"
				CHOICETXT="${G}d${N}(efault), ${G}p${N}(post)"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo -e "Current boot stage is ${G}$CURRTXT${N}."
			echo ""
			echo "Do you want to change it to"
			echo -e "$TMPTXT?"
			echo ""
			echo -en "Enter $CHOICETXT, ${G}b${N}(ack) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			d|D)
				if [ "$SIMSTAGE" != 0 ]; then
					before_change
					OPTNEW=0
					log_handler "Device simulation boot stage changed to default."
					replace_fn SIMSTAGE $SIMSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			p|P)
				if [ "$SIMSTAGE" != 1 ]; then
					before_change
					OPTNEW=1
					log_handler "Device simulation boot stage changed to post-fs-data."
					replace_fn SIMSTAGE $SIMSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			l|L)
				if [ "$SIMSTAGE" != 2 ]; then
					before_change
					OPTNEW=2
					log_handler "Device simulation boot stage changed to late_start service."
					replace_fn SIMSTAGE $SIMSTAGE $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 3
			;;
		esac
	done
}

# ======================== MagiskHide Props ========================
# Second menu level - MagiskHide props, $1=header
menu_magiskhide_props() {
	INPUT2=""
	while true
	do
		ITEMCOUNT=0
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			echo "Set/reset MagiskHide sensitive props."
			echo ""
			magiskhide_props_menu "$SAFELIST"
			magiskhide_props_menu "$TRIGGERSAFELIST" "trigger"
			magiskhide_props_menu "$LATESAFELIST" "late"
			if [ "$ITEMCOUNT" == 0 ]; then
				echo "None of the sensitive props need"
				echo "to be changed on your device."
				echo "They are all already set to a safe"
				echo "value or does not exist on the device."
				echo ""
				echo "If you still want to change/set one of"
				echo "them, to a value other than the safe"
				echo "ones, use the custom props option."
				echo ""
				if [ "$PROPEDIT" == 1 ]; then
					echo "But, this setting is active..."
					echo "Do you want to disable this feature?"
					echo "(This would save some resources during boot.)"
					echo ""
					echo -e "${G}y${N} - Yes"
					echo -e "${G}n${N} - No"
					echo -e "${G}e${N} - Exit"
					echo ""
					echo "See the module readme or the"
					echo "support thread @ XDA for details."
					echo ""
					echo -n "Enter your desired option: "
					read -r INPUT2
				else
					echo "Nothing to do... Returning to main menu."
					sleep 5
					INPUT=""
					break
				fi
			else
				if [ "$PROPCOUNT" -lt $(($ITEMCOUNT-3)) ]; then
					echo -e "${G}a${N} - Set all props"
				fi
				if [ "$PROPCOUNT" -gt 2 ]; then
					echo -e "${G}r${N} - Reset all props"
				fi
				echo -e "${G}s${N} - Boot stage"
				echo -e "${G}b${N} - Go back to main menu"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo "Pick several options at once by"
				echo "separating inputs with a comma."
				echo "Example: 1,3,4"
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT2
			fi
		fi
		case "$INPUT2" in
			*\,*)
				if [ -z "$(echo $(echo $INPUT2 | sed 's|\,||g') | tr -d [0-9])" ] && [ "$ITEMCOUNT" != 0 ]; then
					menu_change_prop "Set multiple props" $INPUT2
				else
					invalid_input 7 2
				fi
			;;
			a|A)
				if [ "$PROPCOUNT" -lt $(($ITEMCOUNT-3)) ] && [ "$ITEMCOUNT" != 0 ]; then
					menu_change_prop "Set all props"
				else
					invalid_input 1 2
				fi
			;;
			r|R)
				if [ "$PROPCOUNT" -gt 2 ] && [ "$ITEMCOUNT" != 0 ]; then
					menu_reset_prop_all "Reset all props"
				else
					invalid_input 1 2
				fi
			;;
			b|B)
				if  [ "$ITEMCOUNT" != 0 ]; then
					INPUT=""
					break
				else
					invalid_input 1 2
				fi
			;;
			y|Y)
				if  [ "$ITEMCOUNT" == 0 ]; then
					menu_reset_prop_all "Reset all props"
					INPUT2=""
					break
				else
					invalid_input 1 2
				fi
			;;
			n|N)
				if  [ "$ITEMCOUNT" == 0 ]; then
					INPUT=""
					break
				else
					invalid_input 1 2
				fi
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUT2" -ge 1 -a "$INPUT2" -lt "$ITEMCOUNT" ] && [ "$ITEMCOUNT" != 0 ]; then
					ITEMCOUNT=1
					for ITEM in $SAFELIST$TRIGGERSAFELIST$LATESAFELIST; do
						CURRVALUE=$(eval "echo \$$(echo "CURR$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
						ORIGVALUE=$(eval "echo \$$(echo "ORIG$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
						MODULEVALUE=$(eval "echo \$$(echo "MODULE$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
						if [ "$ORIGVALUE" ] && [ "$(get_eq_right "$ITEM")" != "$ORIGVALUE" ]; then
							if [ "$ITEMCOUNT" == "$INPUT2" ]; then
								menu_change_prop "$(get_eq_left "$ITEM")" "$CURRVALUE" "$ORIGVALUE" "$MODULEVALUE"
								break
							fi
							ITEMCOUNT=$(($ITEMCOUNT+1))
						fi
					done
				else
					invalid_input 1 2
				fi
			;;
		esac
	done
}

# Third menu level - MagiskHide props, $1=header, $2=Currently set prop value, $3=Original prop value, $4=Module set prop value
menu_change_prop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$1" == "Set multiple props" ]; then
				TMPITEMS=""
				CNT=1
				TMPLST=$(echo $2 | sed 's|\,| |g')
				for ITEM in $SAFELIST$TRIGGERSAFELIST$LATESAFELIST; do
					ORIGVALUE=$(eval "echo \$$(echo "ORIG$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
					if [ "$ORIGVALUE" ] && [ "$(get_eq_right "$ITEM")" != "$ORIGVALUE" ]; then
						for INT in $TMPLST; do
							if [ "$INT" == "$CNT" ]; then
								if [ "$TMPITEMS" ]; then
									TMPITEMS="$TMPITEMS $(get_eq_left "$ITEM")"
								else
									TMPITEMS=$(get_eq_left "$ITEM")
								fi
							fi
						done
						CNT=$(($CNT+1))
					fi
				done
				echo "Do you want to change the"
				echo "following props:"
				echo ""
				for ITEM in $TMPITEMS; do
					CURRVALUE=$(eval "echo \$$(echo "CURR$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
					safe_props $ITEM $CURRVALUE
					if [ "$SAFE" == 1 ]; then
						SAFETXT=" (currently set to a safe value)"
					else
						SAFETXT=" (currently set to a triggering value)"
					fi
					echo -e ${C}$ITEM${N}$SAFETXT
				done
			elif [ "$1" == "Set all props" ]; then
				echo "Do you want to set all"
				echo "MagiskHide sensitive props?"
				TMPITEMS=$PROPSLIST$TRIGGERPROPS$LATEPROPS
			else
				REPROP=$(echo "RE$(get_prop_type "$1")" | tr '[:lower:]' '[:upper:]')
				# Checks if the prop exists
				if [ "$2" ]; then
					CTRLTRIGG=false
					for TRIGG in $TRIGGERPROPS; do
						if [ "$TRIGG" == "$1" ]; then
							CTRLTRIGG=true
							break
						fi
					done
					if [ "$4" ] && [ "$(get_file_value $LATEFILE "${REPROP}=")" == "true" ]; then
						if [ "$CTRLTRIGG" == "false" ]; then
							PROPMODULETXT=", by this module"
							BACKTXT=" back"
						else
							PROPMODULETXT="${G}active${N}"
							BACKTXT="${R}deactivate${N}"
						fi
					else
						if [ "$CTRLTRIGG" == "false" ]; then
							PROPMODULETXT=""
							BACKTXT=""
						else
							PROPMODULETXT="${R}deactivated${N}"
							BACKTXT="${G}activate${N}"
						fi
					fi
					if [ "$CTRLTRIGG" == "false" ]; then
						echo -e "Currently set to ${C}$2${N}${PROPMODULETXT}."
						if [ "$2" != "$3" ]; then
							echo -e "The original value is ${C}$3${N}."
						fi
						echo ""
						safe_props "$1" "$2"
						change_to "$1" "$2"
						if [ "$SAFE" == 1 ]; then
							echo "You currently have the safe value set."
							echo -e "Are you sure you want to change it$BACKTXT to ${C}$CHANGE${N}?"
						else
							echo -e "Do you want to change it${BACKTXT} to ${C}$CHANGE${N}?"
						fi
					else
						echo -e "Changing of ${C}$1${N} when"
						echo -e "containing triggering value is $PROPMODULETXT."
						echo ""
						echo -e "Are you sure you want to $BACKTXT it."
					fi
				else
					echo "This prop doesn't currently exist on your system."
					echo ""
					echo "Nothing to do... Returning to main menu."
					sleep 3
					INPUT2=""
					break
				fi
			fi
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				if [ "$1" == "Set multiple props" ] || [ "$1" == "Set all props" ]; then
					for ITEM in $TMPITEMS; do
						CURRVALUE=$(eval "echo \$$(echo "CURR$(get_prop_type $(get_eq_left "$ITEM"))" | tr '[:lower:]' '[:upper:]')")
						safe_props "$ITEM" $CURRVALUE
						if [ "$SAFE" == 1 ] && [ "$1" != "Set all props" ]; then
							reset_prop "$ITEM" "none"
						else
							change_to "$ITEM" $CURRVALUE
							change_prop "$ITEM" $CHANGE "none"
						fi
						. $LATEFILE
					done
					after_change "$1"
				elif [ "$PROPMODULETXT" ]; then
					menu_reset_prop "Reset $1" "$1"
				else
					change_prop "$1" $CHANGE
				fi
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Reset all MagiskHide props, $1=header
menu_reset_prop_all() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all prop values"
			echo "to the default device values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_prop_all "$1"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Reset specific MagiskHide prop, $1=header, $2=prop name
menu_reset_prop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset $2"
			echo "to it's default device value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_prop "$2"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Boot stage, $1=header
menu_bootstage_prop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$PROPBOOT" == 0 ]; then
				CURRTXT="default"
				TMPTXT="${C}post-fs-data${N} or ${C}late_start sevice${N}"
				CHOICETXT="${G}p${N}(ost), ${G}l${N}(ate)"
			elif [ "$PROPBOOT" == 1 ]; then
				CURRTXT="post-fs-data"
				TMPTXT="${C}default${N} or ${C}late_start service${N}"
				CHOICETXT="${G}d${N}(efault), ${G}l${N}(ate)"
			elif [ "$PROPBOOT" == 2 ]; then
				CURRTXT="late_start service"
				TMPTXT="${C}default${N} or ${C}post-fs-data${N}"
				CHOICETXT="${G}d${N}(efault), ${G}p${N}(post)"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo -e "Current boot stage is ${G}$CURRTXT${N}."
			echo ""
			echo "Do you want to change it to"
			echo -e "$TMPTXT?"
			echo ""
			echo -en "Enter $CHOICETXT, ${G}b${N}(ack) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			d|D)
				if [ "$PROPBOOT" != 0 ]; then
					before_change
					OPTNEW=0
					log_handler "MagiskHide props boot stage changed to default."
					replace_fn PROPBOOT $PROPBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			p|P)
				if [ "$PROPBOOT" != 1 ]; then
					before_change
					OPTNEW=1
					log_handler "MagiskHide props boot stage changed to post-fs-data."
					replace_fn PROPBOOT $PROPBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			l|L)
				if [ "$PROPBOOT" != 2 ]; then
					before_change
					OPTNEW=2
					log_handler "MagiskHide props boot stage changed to late_start service."
					replace_fn PROPBOOT $PROPBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 3
			;;
		esac
	done
}

# ======================== Custom Props ========================
# Second menu level - Custom props, $1=Header
menu_custom_props() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			ITEMCOUNT=0
			if [ "$OPTIONBOOT" == 0 ]; then
				DEFSTAGETXT=" (system.prop)"
			elif [ "$OPTIONBOOT" == 1 ]; then
				DEFSTAGETXT=" (post-fs-data)"
			elif [ "$OPTIONBOOT" == 2 ]; then
				DEFSTAGETXT=" (late_start service)"
			fi
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			if [ "$CUSTOMEDIT" == 0 ] && [ "$CUSTOMPROPS" -o "$CUSTOMPROPSPOST" -o "$CUSTOMPROPSLATE" -o "$CUSTOMPROPSDELAY" ]; then
				CTRLSET=0
				echo -e "You have ${C}custom props set${N},"
				echo -e "but the option is ${R}not activated${N}."
				echo ""
				echo -e "Do you want to activate it (enter ${G}r${N} to reset)?"
				echo ""
				echo -en "Enter ${G}y${N}(es), ${G}n${N}(o), ${G}r${N}(eset) or ${G}e${N}(xit): "
				read -r INPUT2
			else
				CTRLSET=1
				echo "Set or edit custom prop values for your device."
				echo ""
				if [ "$CUSTOMPROPS" ] || [ "$CUSTOMPROPSPOST" ] || [ "$CUSTOMPROPSLATE" ] || [ "$CUSTOMPROPSDELAY" ]; then
					echo "Currently set props (pick to edit):"
					ITEMCOUNT=1
					if [ "$CUSTOMPROPS" ]; then
						echo ""
						echo -e "${C}Default boot stage${G}${DEFSTAGETXT}${N}"
						for ITEM in $CUSTOMPROPS; do
							echo -e "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
					if [ "$CUSTOMPROPSPOST" ]; then
						echo ""
						echo -e "${C}post-fs-data boot stage${N}"
						for ITEM in $CUSTOMPROPSPOST; do
							echo -e "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
					if [ "$CUSTOMPROPSLATE" ] || [ "$CUSTOMPROPSDELAY" ]; then
						CUSTOMPROPSLATETMP="$CUSTOMPROPSLATE $CUSTOMPROPSDELAY"
						echo ""
						echo -e "${C}late_start service boot stage${N}"
						for ITEM in $CUSTOMPROPSLATETMP; do
							if [ "$(echo $CUSTOMPROPSDELAY | grep $(get_eq_left $ITEM))" ]; then
								DELAYTXT=" ${C}(delayed)${N}"
							else
								DELAYTXT=""
							fi
							echo -e "${G}$ITEMCOUNT${N} - $(get_eq_left "$ITEM")$DELAYTXT"
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					fi
				else
					echo "Currently no custom props set."
					echo "Please add one by selecting"
					echo "\"New custom prop\" below."
				fi
				echo ""
				echo -e "${G}n${N} - New custom prop"
				if [ "$CUSTOMPROPS" ] || [ "$CUSTOMPROPSPOST" ] || [ "$CUSTOMPROPSLATE" ] || [ "$CUSTOMPROPSDELAY" ]; then
					echo -e "${G}r${N} - Reset all custom props"
				fi
				echo -e "${G}b${N} - Go back to main menu"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT2
			fi
			case "$INPUT2" in
				y|Y)
					if [ "$CTRLSET" == 1 ]; then
						invalid_input 1 2
					elif [ "$CTRLSET" == 0 ]; then
						replace_fn CUSTOMEDIT 0 1 $LATEFILE
						INPUT=""
						break
					fi
				;;
				n|N)
					if [ "$CTRLSET" == 1 ]; then
						menu_new_custprop "New custom prop"
					elif [ "$CTRLSET" == 0 ]; then
						INPUT=""
						break
					fi
				;;
				r|R)
					if [ "$CTRLSET" == 1 ]; then
						menu_reset_all_custprop "Reset all custom props"
					elif [ "$CTRLSET" == 0 ]; then
						menu_reset_all_custprop "Reset all custom props"
					fi
				;;
				b|B)
					if [ "$CTRLSET" == 1 ]; then
						INPUT=""
						break
					elif [ "$CTRLSET" == 0 ]; then
						invalid_input 4 2
					fi
				;;
				e|E) exit_fn
				;;
				*)
					if [ "$INPUT2" -ge 1 -a "$INPUT2" -lt "$ITEMCOUNT" ] && [ "$CTRLSET" == 1 ]; then
						ITEMCOUNT=1
						for ITEM in $CUSTOMPROPSLIST; do
							if [ "$ITEMCOUNT" == "$INPUT2" ]; then
								menu_edit_custprop "$(get_eq_left "$ITEM")"
								break
							fi
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					else
						if [ "$CTRLSET" == 1 ]; then
							invalid_input 1 2
						elif [ "$CTRLSET" == 0 ]; then
							invalid_input 4 2
						fi
					fi
				;;
			esac
		fi
	done
}

# Third menu level - Edit custom prop, $1=prop name
menu_edit_custprop() {
	INPUT3=""
	if [ "$(echo $CUSTOMPROPS | grep $1)" ]; then
		STAGETXT=" ${C}(system.prop)${N}"
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ] && [ "$(echo $CUSTOMPROPSLATE | grep $1)" -o "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		STAGETXT=" ${C}(both)${N}"
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ]; then
		STAGETXT=" ${C}(post-fs-data)${N}"
	elif [ "$(echo $CUSTOMPROPSLATE | grep $1)" ] || [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		STAGETXT=" ${C}(late_start service)${N}"
	fi
	DELAYTXT=""
	if [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		for ITEM in $CUSTOMPROPSDELAY; do
			case $ITEM in
				*$1*)
					DELAYTXT=" ${G}(active, $(get_prop_delay "$ITEM") seconds)${N}"
					break
				;;
			esac
		done
	fi
	while true
	do
		if [ -z "$INPUT3" ]; then
			for ITEM in $CUSTOMPROPSLIST; do
				TMPITEM=$(get_prop_value "$ITEM")
				if [ "$(get_eq_left "$ITEM")" == "$1" ]; then
					if [ "$TMPITEM" == "$(getprop $1)" ]; then
						PROPNOTSET=0
					else
						PROPNOTSET=1
					fi
					SETPROPVALUE="$TMPITEM"
					break
				fi
			done
			menu_header "${C}$1${N}"
			echo ""
			echo "The current value for"
			echo -e "${C}$1${N} is:"
			echo ""
			echo -e "${C}$(getprop $1)${N}"
			if [ "$PROPNOTSET" == 0 ]; then
				echo "(Set by this module.)"
				echo ""
				echo "Enter a new value or select"
				echo "from the options below."
				echo ""
			else
				echo ""
				echo -e "${R}Not yet set by this module. Please reboot to set.${N}"
				if [ "$OPTIONBOOT" == 1 ] || [ "$STAGETXT" == " ${C}(post-fs-data)${N}" ] || [ "$STAGETXT" == " ${C}(system.prop)${N}" ]; then
					echo ""
					echo "This might be caused by the prop being set"
					echo "too early. If the above state does not change"
					echo "after a reboot, try changing the boot stage"
					echo -e "when the prop is set to ${G}late_start service${N}."
				fi
				echo ""
				echo -e "Do you want to reboot now (${G}y/n${N})?"
				echo ""
			fi
			echo -e "${G}s${N} - Prop boot stage$STAGETXT"
			echo -e "${G}d${N} - Delay$DELAYTXT"
			echo -e "${G}r${N} - Reset prop"
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y) force_reboot
			;;
			n|N)
				INPUT2=""
				break
			;;
			s|S) menu_bootstage_custprop "$1" "$SETPROPVALUE"
			;;
			d|D) menu_delay_custprop "$1" "$SETPROPVALUE" "$(getprop $1)" "edit"
			;;
			r|R)
				menu_reset_custprop "$1" "$SETPROPVALUE"
				break
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$PROPNOTSET" == 0 ]; then
					menu_set_custprop "$1" "$INPUT3" "$(getprop $1)"
					break
				else
					invalid_input 1 3
				fi
			;;
		esac
	done
}

# Third menu level - New custom prop, $1=Header
menu_new_custprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the prop to set. Example:"
			echo -e "${C}ro.sf.lcd_density${N}"
			echo ""
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			""|[[:blank:]]*) blank_input 3
			;;
			*)
				PROP=$(get_prop_type $INPUT3)
				REPROP=$(echo "RE${PROP}" | tr '[:lower:]' '[:upper:]')
				ORIGPROP=$(echo "ORIG${PROP}" | tr '[:lower:]' '[:upper:]')
				MODULEPROP=$(echo "MODULE${PROP}" | tr '[:lower:]' '[:upper:]')
				if [ "$(eval "echo \$$REPROP")" == "true" ] && [ "$(eval "echo \$$ORIGPROP")" ] && [ "$(eval "echo \$$MODULEPROP")" ] || [ "$(echo $CUSTOMPROPSLIST | grep -Eo "(^| )$INPUT3($| )")" ]; then
					menu_magiskhide_custprop "$INPUT3"
				else
					menu_set_new_custprop "$INPUT3"
					break
				fi
			;;
		esac
	done
}

# Third menu level - Reset all custom props, $1=Header
menu_reset_all_custprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all"
			echo "custom prop values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_all_custprop
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Fourth menu level - MagiskHide custom prop and duplicate props, $1=prop name
menu_magiskhide_custprop() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$(echo "$CUSTOMPROPSLIST" | grep -o $1)" ]; then
				TMPCHK="b"
				echo -e "${C}$1${N} is"
				echo "already on your list of custom props."
				echo "No need to set it again."
				echo ""
				echo -e "${G}b${N} - Go back"
			else
				TMPCHK="n"
				echo -e "${C}$1${N} is"
				echo "one of the sensitive props that can be"
				echo "set by the MagiskHide props option."
				echo "Are you sure you want to proceed?"
				echo ""
				echo -e "${G}y${N} - Yes"
				echo -e "${G}n${N} - No"
			fi
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				menu_set_new_custprop "$1"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				if [ "$TMPCHK" == "n" ]; then
					INPUT3=""
					break
				else
					invalid_input 1 4
				fi
			;;
			b|B)
				if [ "$TMPCHK" == "b" ]; then
					INPUT3=""
					break
				else
					invalid_input 1 4
				fi
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 4
			;;
		esac
	done
}

# Fourth menu level - Set new custom prop, $1=prop name
menu_set_new_custprop() {
	INPUT4=""
	TMPPROP=$(getprop "$1")
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the value you want to set"
			echo -e "${C}$1${N} to,"
			echo "or select from the options below."
			echo ""
			echo "The currently set value is:"
			if [ "$TMPPROP" ]; then
				echo -e "${C}$TMPPROP${N}"
				echo "Please enter the new value."
			else
				echo -e "${C}Currently not set, or the value could not be retrieved.${N}"
				echo "Please enter the value to set."
			fi
			echo ""
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			b|B)
				INPUT2=""
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			""|[[:blank:]]*)	blank_input 4
			;;
			*)
				menu_set_custprop "$1" "$INPUT4" "$TMPPROP"
				INPUT2=""
				INPUT3=""
				break
			;;
		esac
	done
}

# Fourth menu level - Custom prop boot stage, $1=prop name, $2=prop value
menu_bootstage_custprop() {
	INPUT4=""
	PLEND=" is"
	DEFAULTTXT=""
	POSTTXT=""
	LATETXT=""
	BOTHTXT=""
	OPTTYPE1="default"
	OPTTYPE2="post"
	OPTTYPE3="late"
	OPTTYPE4="both"
	if [ "$(echo $CUSTOMPROPS | grep $1)" ]; then
		TMPBSTAGE="default"
		DEFAULTTXT="${G} (current)${N}"
		INTOPT=1
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ]; then
		TMPBSTAGE="post-fs-data"
		POSTTXT="${G} (current)${N}"
		INTOPT=2
	elif [ "$(echo $CUSTOMPROPSLATE | grep $1)" ] || [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		TMPBSTAGE="late_start service"
		if [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
			LATETXT="${G} (current, delayed)${N}"
		else
			LATETXT="${G} (current)${N}"
		fi
		INTOPT=3
	elif [ "$(echo $CUSTOMPROPSPOST | grep $1)" ] && [ "$(echo $CUSTOMPROPSLATE | grep $1)" ]; then
		TMPBSTAGE="both"
		PLEND="s are"
		BOTHTXT="${G} (current)${N}"
		INTOPT=4
	else
		TMPBSTAGE=""
	fi
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Select what boot stage"
			echo -e "${C}$1${N}"
			echo "should be set in."
			echo ""
			echo -e "Currently ${C}${TMPBSTAGE}${N}"
			echo "boot stage$PLEND used."
			echo ""
			echo "Select an option below."
			echo ""
			echo -e "${G}1${N} - Default${DEFAULTTXT}"
			echo -e "${G}2${N} - post-fs-data${POSTTXT}"
			echo -e "${G}3${N} - late_start service${LATETXT}"
			echo -e "${G}4${N} - Both boot stages${BOTHTXT}"
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT4
		fi
		case "$INPUT4" in
			1|2|3|4)
				if [ "$INTOPT" == "$INPUT4" ]; then
					INPUT4=""
					active_option
				else
					OPTTYPE="OPTTYPE${INPUT4}"
					set_custprop "$1" "$2" "$(eval "echo \$$OPTTYPE")"
					DELAYTXT=""
					INPUT3=""
					break
				fi
			;;
			b|B)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 4
			;;
		esac
	done
}

# Fourth menu level - Reset custom prop, $1=prop name, $2=prop value
menu_reset_custprop() {
	INPUT4=""
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo -e "This will reset ${C}$1${N}"
			echo "to its original value."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				reset_custprop "$1" "$2"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				INPUT4=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 4
			;;
		esac
	done
}

# Fifth menu level - Set custom prop, $1=prop name, $2=prop value, $3=current value, $4=option
menu_set_custprop() {
	PROPSTAGE="default"
	DEFAULTTXT=" ${G}(current)${N}"
	POSTTXT=""
	LATETXT=""
	BOTHTXT=""
	DELAYTXT=""
	DELAYVAL=""
	DELAYTIMING=""
	if [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		for ITEM in $CUSTOMPROPSDELAY; do
			case $ITEM in
				*$1*)
					DELAYTXT=" ${G}(active)${N}"
					break
				;;
			esac
		done
	fi
	INPUT5=""
	while true
	do
		if [ -z "$INPUT5" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo -e "This will set ${C}$1${N} to:"
			echo ""
			echo -e "${C}$2${N}"
			echo ""
			if [ "$4" == "option" ]; then
				echo "The currently set value is:"
				if [ "$(getprop "$1")" ]; then
					echo -e "${C}$(getprop "$1")${N}"
					echo "Please enter the new value."
				else
					echo -e "${C}Currently not set, or the value could not be retrieved.${N}"
					echo "Please enter the value to set."
				fi
				echo ""
			fi
			echo "Pick an option below to change"
			echo "what boot stage the prop will"
			echo "be set in, or set/reset a delay:"
			echo ""
			echo -e "${G}1${N} - Default${DEFAULTTXT}"
			echo -e "${G}2${N} - post-fs-data${POSTTXT}"
			echo -e "${G}3${N} - late_start service${LATETXT}"
			echo -e "${G}4${N} - Both boot stages${BOTHTXT}"
			echo -e "${G}d${N} - Delay${DELAYTXT}"
			echo ""
			echo "Do you want to continue?"
			echo ""
			if [ "$4" == "option" ]; then
				echo -e "Enter ${G}y${N}(es) or ${G}n${N}(o)"
			else
				echo -e "Enter ${G}y${N}(es), ${G}n${N}(o), ${G}e${N}(xit)"
			fi
			echo -n "or an option from above: "
			read -r INPUT5
		fi
		case "$INPUT5" in
			1)
				if [ "$DEFAULTTXT" ]; then
					INPUT5=""
					active_option
				else
					PROPSTAGE="default"
					DEFAULTTXT=" ${G}(current)${N}"
					POSTTXT=""
					LATETXT=""
					BOTHTXT=""
					DELAYTXT=""
					DELAYVAL=""
					DELAYTIMING=""
					INPUT5=""
				fi
			;;
			2)
				if [ "$POSTTXT" ]; then
					INPUT5=""
					active_option
				else
					PROPSTAGE="post"
					DEFAULTTXT=""
					POSTTXT=" ${G}(current)${N}"
					LATETXT=""
					BOTHTXT=""
					DELAYTXT=""
					DELAYVAL=""
					DELAYTIMING=""
					INPUT5=""
				fi
			;;
			3)
				if [ "$LATETXT" ]; then
					INPUT5=""
					active_option
				else
					PROPSTAGE="late"
					DEFAULTTXT=""
					POSTTXT=""
					LATETXT=" ${G}(current)${N}"
					BOTHTXT=""
					DELAYTXT=""
					DELAYVAL=""
					DELAYTIMING=""
					INPUT5=""
				fi
			;;
			4)
				if [ "$BOTHTXT" ]; then
					INPUT5=""
					active_option
				else
					PROPSTAGE="both"
					DEFAULTTXT=""
					POSTTXT=""
					LATETXT=""
					BOTHTXT=" ${G}(current)${N}"
					DELAYTXT=""
					DELAYVAL=""
					DELAYTIMING=""
					INPUT5=""
				fi
			;;
			d|D) menu_delay_custprop "$1" "$2" "$3" "new"
			;;
			y|Y)
				set_custprop "$1" "$2" "$PROPSTAGE" "$3" "$DELAYVAL" "$DELAYTIMING"
				INPUT2=""
				INPUT3=""
				INPUT4=""
				INPUT5=""
				break
			;;
			n|N)
				INPUT4=""
				INPUT5=""
				break
			;;
			e|E)
				if [ "$4" == "option" ]; then
					invalid_input 2 5
				else
					exit_fn
				fi
			;;
			*)
				if [ "$4" == "option" ]; then
					invalid_input 2 5
				else
					invalid_input 3 5
				fi
			;;
		esac
	done
}

# Fourth or sixth menu level - Delay prop, $1=prop name, $2=prop value, $3=current value, $4=new or edit
menu_delay_custprop() {
	INPUTTMP=""
	TMPDELAY="$DELAYVAL"
	TIMINGTXT=" ${G}(Wait for \"Boot completed\")${N}"
	TIMINGOPT="boot"
	if [ "$4" == "edit" ]; then
		INPUT4=""
		if [ "$CUSTOMPROPSDELAY" ]; then
			for ITEM in $CUSTOMPROPSDELAY; do
				case $ITEM in
					*$1*)
						TMPDELAY="$(get_prop_delay "$ITEM")"
						if [ "$(get_prop_delay_exec "$ITEM")" != "boot" ]; then
							TIMINGTXT=" ${G}(Run immediately)${N}"
							TIMINGOPT=""
						fi
					;;
				esac
			done
		fi
	elif [ "$4" == "new" ]; then
		INPUT6=""
	fi
	while true
	do
		if [ "$4" == "edit" ] && [ -z "$INPUT4" ] || [ "$4" == "new" ] && [ -z "$INPUT6" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the time (in seconds)"
			echo "you want the prop"
			echo -e "${C}$1${N}"
			echo "to be delayed."
			if [ "$TMPDELAY" ]; then
				echo ""
				echo "Currently delayed by"
				echo -e "${C}$TMPDELAY${N} seconds"
			fi
			echo ""
			echo "Note that this prop will"
			echo "automatically be set during the"
			echo "late_start service boot stage."
			echo ""
			echo -e "${G}t${N} - Change timing$TIMINGTXT"
			if [ "$DELAYTXT" ]; then
				echo -e "${G}r${N} - Reset delay"
			fi
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			if [ "$4" == "edit" ]; then
				read -r INPUT4
			elif [ "$4" == "new" ]; then
				read -r INPUT6
			fi
		fi
		if [ "$4" == "edit" ]; then
			INPUTTMP=$INPUT4
		elif [ "$4" == "new" ]; then
			INPUTTMP=$INPUT6
		fi
		case "$INPUTTMP" in
			t|T)
				if [ "$TIMINGOPT" ]; then
					TIMINGTXT=" ${G}(Run immediately)${N}"
					TIMINGOPT=""
				else
					TIMINGTXT=" ${G}(Wait for \"Boot completed\")${N}"
					TIMINGOPT="boot"
				fi
				if [ "$4" == "edit" ]; then
					INPUT4=""
					INPUTTMP=""
				elif [ "$4" == "new" ]; then
					INPUT6=""
					INPUTTMP=""
				fi
			;;
			r|R) menu_reset_delay_custprop "$1" "$2" "$3" "$4"
			;;
			b|B)
				if [ "$4" == "edit" ]; then
					INPUT3=""
					break
				elif [ "$4" == "new" ]; then
					INPUT5=""
					break
				fi
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$INPUTTMP" ]; then
					NUMCHECK="$(echo $INPUTTMP | tr -d [0-9])"
					if [ -z "$NUMCHECK" ]; then
						if  [ "$4" == "edit" ]; then
							STAGETXT=" ${C}(late_start service)${N}"
							DELAYTXT=" ${G}(active, $INPUTTMP seconds)${N}"
							INPUT3=""
							set_custprop "$1" "$2" "delay" "$3" "$INPUTTMP" "$TIMINGOPT"
							break
						elif [ "$4" == "new" ]; then
							PROPSTAGE="delay"
							DEFAULTTXT=""
							POSTTXT=""
							LATETXT=" ${G}(current)${N}"
							BOTHTXT=""
							DELAYTXT=" ${G}(active)${N}"
							DELAYVAL="$INPUTTMP"
							DELAYTIMING="$TIMINGOPT"
							INPUT5=""
							break
						fi
					else
						if [ "$4" == "edit" ]; then
							invalid_input 8 4
						elif [ "$4" == "new" ]; then
							invalid_input 8 6
						fi
					fi
				else
					if [ "$4" == "edit" ]; then
						invalid_input 8 4
					elif [ "$4" == "new" ]; then
						invalid_input 8 6
					fi
				fi
			;;
		esac
	done
}

# Fifth or seventh level - Reset delay, $1=prop name, $2=prop value, $3=current value, $4=new or edit
menu_reset_delay_custprop() {
	if [ "$4" == "edit" ]; then
		INPUT5=""
	elif [ "$4" == "new" ]; then
		INPUT7=""
	fi
	INPUTTMP=""
	TMPDELAY=""
	if [ "$(echo $CUSTOMPROPSDELAY | grep $1)" ]; then
		for ITEM in $CUSTOMPROPSDELAY; do
			case $ITEM in
				*$1*)
					TMPDELAY="$(get_prop_delay "$ITEM")"
					break
				;;
			esac
		done
	fi
	while true
	do
		if [ "$4" == "edit" ] && [ -z "$INPUT5" ] || [ "$4" == "new" ] && [ -z "$INPUT7" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Do you want to reset"
			echo "the delay for prop"
			echo -e "${C}$1${N}"
			echo ""
			echo "The current delay is"
			echo -e "${C}$TMPDELAY${N} seconds"
			echo ""
			echo "This will move the prop back"
			echo "to the default boot stage."
			echo ""
			echo -e "${G}y${N} - Yes"
			echo -e "${G}n${N} - No"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			if [ "$4" == "edit" ]; then
				read -r INPUT5
			elif [ "$4" == "new" ]; then
				read -r INPUT7
			fi
		fi
		if [ "$4" == "edit" ]; then
			INPUTTMP=$INPUT5
		elif [ "$4" == "new" ]; then
			INPUTTMP=$INPUT7
		fi
		case "$INPUTTMP" in
			y|Y)
				set_custprop "$1" "$2" "default" "$3"
				if [ "$4" == "edit" ]; then
					INPUT3=""
					INPUT4=""
					break
				elif [ "$4" == "new" ]; then
					INPUT5=""
					INPUT6=""
					break
				fi
			;;
			n|N)
				if [ "$4" == "edit" ]; then
					INPUT4=""
					break
				elif [ "$4" == "new" ]; then
					INPUT6=""
					break
				fi
			;;
			e|E) exit_fn
			;;
			*)
				if [ "$4" == "edit" ]; then
					invalid_input 3 5
				elif [ "$4" == "new" ]; then
					invalid_input 3 7
				fi
			;;
		esac
	done
}

# ======================== Delete Props ========================
# Second menu level - Delete props, $1=header
menu_delete_props() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			ITEMCOUNT=0
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			if [ "$DELEDIT" == 0 ] && [ "$DELETEPROPS" ]; then
				CTRLSET=0
				echo -e "You have a list of ${C}props to delete${N},"
				echo -e "but the option is ${R}not activated${N}."
				echo ""
				echo -e "Do you want to activate it (enter ${G}r${N} to reset)?"
				echo ""
				echo -en "Enter ${G}y${N}(es), ${G}n${N}(o), ${G}r${N}(eset) or ${G}e${N}(xit): "
				read -r INPUT2
			else
				CTRLSET=1
				echo "Delete prop values on your device."
				echo ""
				if [ "$DELETEPROPS" ]; then
					ITEMCOUNT=1
					echo "Select a prop below to reset it."
					echo ""
					for ITEM in $DELETEPROPS; do
						echo -e "${G}$ITEMCOUNT${N} - $ITEM"
						ITEMCOUNT=$(($ITEMCOUNT+1))
					done
				else
					echo "Currently no props set for removal."
					echo "Please add one by selecting"
					echo "\"New prop\" below."
				fi
				echo ""
				echo -e "${G}n${N} - New prop"
				if [ "$CUSTOMPROPS" ]; then
					echo -e "${G}r${N} - Reset all props"
				fi
				echo -e "${G}b${N} - Go back to main menu"
				echo -e "${G}e${N} - Exit"
				echo ""
				echo "See the module readme or the"
				echo "support thread @ XDA for details."
				echo ""
				echo -n "Enter your desired option: "
				read -r INPUT2
			fi
			case "$INPUT2" in
				y|Y)
					if [ "$CTRLSET" == 1 ]; then
						invalid_input 1 2
					elif [ "$CTRLSET" == 0 ]; then
						replace_fn DELEDIT 0 1 $LATEFILE
						INPUT=""
						break
					fi
				;;
				n|N)
					if [ "$CTRLSET" == 1 ]; then
						menu_new_delprop "New prop"
					elif [ "$CTRLSET" == 0 ]; then
						INPUT=""
						break
					fi
				;;
				r|R)
					if [ "$CTRLSET" == 1 ]; then
						menu_reset_all_delprop "Reset all props"
					elif [ "$CTRLSET" == 0 ]; then
						menu_reset_all_delprop "Reset all props"
					fi
				;;
				b|B)
					if [ "$CTRLSET" == 1 ]; then
						INPUT=""
						break
					elif [ "$CTRLSET" == 0 ]; then
						invalid_input 4 2
					fi
				;;
				e|E) exit_fn
				;;
				*)
					if [ "$INPUT2" -ge 1 -a "$INPUT2" -lt "$ITEMCOUNT" ] && [ "$CTRLSET" == 1 ]; then
						ITEMCOUNT=1
						for ITEM in $DELETEPROPS; do
							if [ "$ITEMCOUNT" == "$INPUT2" ]; then
								menu_reset_delprop "$ITEM"
								break
							fi
							ITEMCOUNT=$(($ITEMCOUNT+1))
						done
					else
						if [ "$CTRLSET" == 1 ]; then
							invalid_input 1 2
						elif [ "$CTRLSET" == 0 ]; then
							invalid_input 4 2
						fi
					fi
				;;
			esac
		fi
	done
}

# Third menu level - Reset deleted prop, $1=header/prop name
menu_reset_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo -e "This will remove ${C}$1${N}"
			echo "from the list of props to delete."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_delprop "$1"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - New prop to delete, $1=header
menu_new_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Enter the prop to delete. Example:"
			echo -e "${C}ro.sf.lcd_density${N}"
			echo ""
			echo -e "${G}b${N} - Go back"
			echo -e "${G}e${N} - Exit"
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT3
		fi
		case "$INPUT3" in
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			""|[[:blank:]]*) blank_input 3
			;;
			*)
				menu_set_new_delprop "$INPUT3"
				break
			;;
		esac
	done
}

# Third menu level - Reset all deleted props, $1=header
menu_reset_all_delprop() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset the entire"
			echo "list of props to delete."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				reset_all_delprop
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Fourth menu level - Set new prop to delete, $1=header/prop name
menu_set_new_delprop() {
	INPUT4=""
	TMPPROP=$(getprop "$1")
	while true
	do
		if [ -z "$INPUT4" ]; then
			menu_header "${C}$1${N}"
			echo ""
			if [ "$TMPPROP" ]; then
				echo "The current value is:"
				echo -e "${C}$TMPPROP${N}"
				echo ""
				echo "This will delete"
				echo -e "${C}$1${N}"
				echo "from your system."
			else
				echo "This prop doesn't currently exist on your system."
				echo ""
				echo "Nothing to do... Returning to main menu."
				sleep 3
				INPUT2=""
				INPUT3=""
				break
			fi
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT4
		fi
		case "$INPUT4" in
			y|Y)
				set_delprop "$1"
				INPUT2=""
				INPUT3=""
				break
			;;
			n|N)
				INPUT3=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 4
			;;
		esac
	done
}

# ======================== Options ========================
# Second menu level - Options, $1=header
menu_options() {
	INPUT2=""
	while true
	do
		COLOURTXT=""
		PRINTSCHKTXT=""
		if [ -z "$INPUT2" ]; then
			if [ "$OPTIONBOOT" == 0 ]; then
				BOOTTXT="system.prop"
			elif [ "$OPTIONBOOT" == 1 ]; then
				BOOTTXT="post-fs-data"
			elif [ "$OPTIONBOOT" == 2 ]; then
				BOOTTXT="late_start service"
			fi
			if [ "$OPTIONCOLOUR" == 1 ]; then
				COLOURTXT="enabled"
				CC=${G}
			else
				COLOURTXT="disabled"
				CC=${R}
			fi
			if [ "$OPTIONWEBP" == 1 ]; then
				PRINTSCHKTXT="enabled"
				CP=${G}
			else
				PRINTSCHKTXT="disabled"
				CP=${R}
			fi
			if [ "$OPTIONWEBU" == 1 ]; then
				MUPDATECHKTXT="enabled"
				CMU=${G}
			else
				MUPDATECHKTXT="disabled"
				CMU=${R}
			fi
			if [ "$OPTIONUPDATE" == 1 ]; then
				PUPDATECHKTXT="enabled"
				CPU=${G}
			else
				PUPDATECHKTXT="disabled"
				CPU=${R}
			fi
			if [ "$OPTIONBACK" == 1 ]; then
				BACKCHKTXT="enabled"
				CB=${G}
			else
				BACKCHKTXT="disabled"
				CB=${R}
			fi
			menu_header "${C}$1${N}\n Select an option below:"
			echo ""
			echo -e "${G}1${N} - Boot stage (currently ${C}${BOOTTXT}${N})"
			echo -e "${G}2${N} - Script colours (currently ${CC}${COLOURTXT}${N})"
			echo -e "${G}3${N} - Automatic module update check (currently ${CMU}${MUPDATECHKTXT}${N})"
			echo -e "${G}4${N} - Automatic update of fingerprints list (currently ${CP}${PRINTSCHKTXT}${N})"
			echo -e "${G}5${N} - Automatic fingerprints update (currently ${CPU}${PUPDATECHKTXT}${N})"
			echo -e "${G}6${N} - Background boot script (currently ${CB}${BACKCHKTXT}${N})"
			echo -e "${G}x${N} - Export settings"
			echo -e "${G}r${N} - Reset all settings"
			if [ "$2" != "s" ]; then
				echo -e "${G}b${N} - Go back to main menu"
			fi
			echo -e "${G}e${N} - Exit"
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT2
		fi
		case "$INPUT2" in
			1) menu_options_bootstage "Boot stage" "$BOOTTXT"
			;;
			2) menu_option_chng "Script colours" "$COLOURTXT" "Script colours are" "OPTIONCOLOUR"
			;;
			3) menu_option_chng "Automatic module update check" "$MUPDATECHKTXT" "Automatic checking for a module update\nis" "OPTIONWEBU"
			;;
			4) menu_option_chng "Automatic update of fingerprints list" "$PRINTSCHKTXT" "Automatic updating of the fingerprints\nlist is" "OPTIONWEBP"
			;;
			5) menu_option_chng "Automatic fingerprints update" "$PUPDATECHKTXT" "Automatic updating of the applied\nfingerprint is" "OPTIONUPDATE"
			;;
			6) menu_option_chng "Background boot script" "$BACKCHKTXT" "Background boot script execution\nis" "OPTIONBACK"
			;;
			x|X) menu_option_export "Export settings"
			;;
			r|R) menu_options_reset "Reset all settings"
			;;
			b|B)
				if [ "$2" == "s" ]; then
					invalid_input 1 2
				else
					INPUT=""
					break
				fi
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# Third menu level - Options, boot stage, $1=header, $2=Current stage
menu_options_bootstage() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "system.prop" ]; then
				TMPTXT="${C}post-fs-data${N} or ${C}late_start sevice${N}"
				CHOICETXT="${G}p${N}(ost), ${G}l${N}(ate)"
			elif [ "$2" == "post-fs-data" ]; then
				TMPTXT="${C}system.prop${N} or ${C}late_start service${N}"
				CHOICETXT="${G}s${N}(ystem.prop), ${G}l${N}(ate)"
			elif [ "$2" == "late_start service" ]; then
				TMPTXT="${C}system.prop${N} or ${C}post-fs-data${N}"
				CHOICETXT="${G}s${N}(ystem.prop), ${G}p${N}(post)"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo -e "Current boot stage is ${G}$2${N}."
			echo ""
			echo "Do you want to change it to"
			echo -e "$TMPTXT?"
			echo ""
			echo -en "Enter $CHOICETXT, ${G}b${N}(ack) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			s|S)
				if [ "$OPTIONBOOT" != 0 ]; then
					before_change
					OPTNEW=0
					log_handler "Boot stage changed to system.prop."
					replace_fn OPTIONBOOT $OPTIONBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			p|P)
				if [ "$OPTIONBOOT" != 1 ]; then
					before_change
					OPTNEW=1
					log_handler "Boot stage changed to post-fs-data."
					replace_fn OPTIONBOOT $OPTIONBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			l|L)
				if [ "$OPTIONBOOT" != 2 ]; then
					before_change
					OPTNEW=2
					log_handler "Boot stage changed to late_start service."
					replace_fn OPTIONBOOT $OPTIONBOOT $OPTNEW $LATEFILE
					# Load module values
					. $LATEFILE
					INPUT2=""
					after_change "$1"
					break
				else
					invalid_input 1 3
				fi
			;;
			b|B)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 3
			;;
		esac
	done
}

# Third menu level - Options, general function, $1=header, $2=is option disabled or enabled, $3=information text
menu_option_chng() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			if [ "$2" == "enabled" ]; then
				TMPTXT="disable"
				OPTCURR=1
				OPTNEW=0
				EXECCURR="background"
				EXECNEW="regular"
			else
				TMPTXT="enable"
				OPTCURR=0
				OPTNEW=1
				EXECCURR="regular"
				EXECNEW="background"
			fi
			menu_header "${C}$1${N}"
			echo ""
			echo -e "$3 currently ${G}$2${N}."
			echo ""
			echo -e "Do you want to ${C}$TMPTXT${N} it?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "$1 was ${TMPTXT}d."
				replace_fn $4 $OPTCURR $OPTNEW $LATEFILE
				if [ "$4" == "OPTIONBACK" ]; then
					sed -i -e "s|^{|\#anch${OPTCURR}|;s|^\#anch${OPTNEW}|{|;s|$EXECCURR|$EXECNEW|" $MODPATH/post-fs-data.sh
				fi
				# Load module values
				. $LATEFILE
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Export all settings to a module configuration file, $1=header
menu_option_export() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will will export all settings"
			echo "to a module configuration file."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				export_settings "$1"
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# Third menu level - Options, reset all options, $1=header
menu_options_reset() {
	INPUT3=""
	while true
	do
		if [ -z "$INPUT3" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will reset all script settings"
			echo "to their default values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT3
		fi
		case "$INPUT3" in
			y|Y)
				log_handler "Resetting all script settings."
				replace_fn OPTIONBOOT $OPTIONBOOT 0 $LATEFILE
				replace_fn OPTIONCOLOUR $OPTIONCOLOUR 1 $LATEFILE
				replace_fn OPTIONWEBP $OPTIONWEBP 1 $LATEFILE
				replace_fn OPTIONWEBU $OPTIONWEBU 1 $LATEFILE
				replace_fn OPTIONUPDATE $OPTIONUPDATE 1 $LATEFILE
				replace_fn OPTIONBACK $OPTIONBACK 0 $LATEFILE
				# Load module values
				. $LATEFILE
				INPUT2=""
				break
			;;
			n|N)
				INPUT2=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 3 3
			;;
		esac
	done
}

# ======================== Logs ========================
# Second menu level - Logs, $1=header, $2=Run as a command flag or not
menu_logs() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "This will package the Magisk log and the"
			echo "module specific log files, together with"
			echo "all the original and current prop values"
			echo "and save it on your device."
			echo ""
			echo "If you are having issues, please upload"
			echo "the packaged file to the support thread"
			echo "@ XDA, with a detailed description."
			echo ""
			echo "Do you want to contine?"
			echo ""
			if [ "$2" == "l" ]; then
				echo -en "Enter ${G}y${N}(es) or ${G}n${N}(o): "
			else
				echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			fi
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)
				collect_logs "$1" "$2"
				INPUT=""
				break
			;;
			n|N)
				if [ "$2" == "l" ]; then
					exit_fn
				else
					INPUT=""
					break
				fi
			;;
			e|E)
				if [ "$2" == "l" ]; then
					invalid_input 1 2
				else
					exit_fn
				fi
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# ======================== Perform module update check ========================
# Second menu level - Reset all options and settings, $1=header
menu_update_check() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "Do you want to check online if there"
			echo "is an update to module?"
			echo ""
			echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)
				update_check "manual"
				INPUT=""
				break
			;;
			n|N)
				INPUT=""
				break
			;;
			e|E) exit_fn
			;;
			*)	invalid_input 1 2
			;;
		esac
	done
}

# ======================== Reset all options and settings ========================
# Second menu level - Reset all options and settings, $1=header, $2=Run as a command flag or not
reset_everything() {
	INPUT2=""
	while true
	do
		if [ -z "$INPUT2" ]; then
			menu_header "${C}$1${N}"
			echo ""
			echo "All module options and settings"
			echo "will be reset to the default values."
			echo ""
			echo "Do you want to continue?"
			echo ""
			if [ "$2" == "r" ]; then
				echo -en "Enter ${G}y${N}(es) or ${G}n${N}(o): "
				LOGTXT=" (option -r)"
				INV1=2
				INV2=1
			else
				echo -en "Enter ${G}y${N}(es), ${G}n${N}(o) or ${G}e${N}(xit): "
				LOGTXT=""
				INV1=3
				INV2=2
			fi
			read -r INPUT2
		fi
		case "$INPUT2" in
			y|Y)
				log_handler "Resetting all module settings$LOGTXT."
				reset_fn "$1" "$2"
				INPUT=""
				break
			;;
			n|N)
				if [ "$2" == "r" ]; then
					exit_fn
				else
					INPUT=""
					break
				fi
			;;
			e|E)
				if [ "$2" == "r" ]; then
					invalid_input $INV1 $INV2
				else
					exit_fn
				fi
			;;
			*)	invalid_input $INV1 $INV2
			;;
		esac
	done
}

# ====================================================
# =================== Script check ===================
# ====================================================

ISSUECHK=0
if [ "$ISSUECHK" == 0 ] && [ ! -f "$LATEFILE" ]; then
	log_handler "The module settings file can't be found."
	ISSUECHK=1
	ISSUETXT="The module settings file can't be found.\n\n Please reboot your device to reset."
fi

# Load module settings
all_values

orig_check
if  [ "$ISSUECHK" == 0 ] && [ "$ORIGLOAD" == 0 ]; then
	log_handler "Original prop values are not loaded in late_start service boot script."
	ISSUECHK=1
	ISSUETXT="The original prop values are not loaded,\n possibly due to a full reset of the module,\n or something has gone wrong.\n\n Please reboot your device to reset."
fi

script_ran_check
if [ "$ISSUECHK" == 0 ] && [ "$POSTCHECK" == 0 ] && [ "$LATECHECK" == 0 ]; then
	log_handler "None of the module scripts ran during boot."
	ISSUECHK=1
	ISSUETXT="None of the module scripts appear\n to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n they do run."
elif [ "$ISSUECHK" == 0 ] && [ "$POSTCHECK" == 0 ]; then
	log_handler "The post-fs-data.sh module script did not run during boot."
	ISSUECHK=1
	ISSUETXT="The post-fs-data.sh module script does not\n appear to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n it does run."
elif [ "$ISSUECHK" == 0 ] && [ "$LATECHECK" == 0 ]; then
	log_handler "The service.sh module script did not run during boot."
	ISSUECHK=1
	ISSUETXT="The service.sh module script does not\n appear to have run during boot.\n\n This means the module won't work.\n\n Please reboot your device and see if\n it does run."
fi

if [ "$ISSUECHK" == 1 ] && [ "$1" != "-s" ]; then
	collect_logs "issue"
	reboot_fn "${ISSUETXT}\n\n Things to try:\n Disable other modules.\n (Cloudflare and EdXposed are known examples)\n Change boot stage settings or background\n execution for the boot script\n (run the props\n command with the -s option).\n\n If the issue persists after a reboot,\n please report the issue, ${R}with logs!${C}\n\n Logs have automatically been saved\n to your internal storage\n ${R}(propslogs.tar.gz)${C}.\n\n If the automatic collection failed,\n please collect the logs manually.\n\n ${G}See the documentation for further details.${N}" "reset-script"
fi

# ====================================================
# ====================== Options =====================
# ====================================================

# Testing connection
test_connection "$1"

if [ "$1" ]; then
	invalid_option() {
		log_handler "Invalid option."
		clear
		menu_header "${C}Help${N}"
		echo ""
		echo -e "${R}Invalid option.${N}"
		echo ""
		echo "Try again without options,"
		echo "or use -h for help and details."
		echo ""
		log_handler "Exiting... Bye bye.\n\n===================="
		exit 0
	}

	# Check for second input variable. If found, set custom prop
	if [ "$2" ]; then
		log_handler "Setting custom prop from command prompt."
		clear
		menu_set_custprop "$1" "$2" "$(getprop $1)" "option"
		clear
		echo "Done."
		echo ""
		log_handler "Exiting... Bye bye.\n\n===================="
		exit 0
	else
		case "$1" in
			*\.*|*\=*) invalid_option
			;;
			*d*|*f*|*l*|*h*|*nc*|*nw*|*r*|*s*|*t*|*u*) # Do nothing
			;;
			*) invalid_option
			;;
		esac
	fi

	# Check non-combinable options
	for ITEM1 in $SOLORUN; do
		case "$1" in
			*$ITEM1*)
				for ITEM2 in $SOLORUN; do
					if [ "$ITEM1" != "$ITEM2" ]; then
						case "$1" in
							*$ITEM2*)
								invalid_option
							;;
						esac
					fi
				done
			;;
		esac
	done

	# Help menu
	case "$1" in
		-h)
			log_handler "Showing help (-h)."
			clear
			menu_header "${C}Help${N}"
			echo ""
			echo -e $(echo $(get_file_value $MODPATH/module.prop "description=") | sed 's|, |,\\n|g' | sed 's|\. |\.\\n|g')
			echo ""
			echo "Usage: props NAME VALUE"
			echo "   or: props [options]..."
			echo ""
			echo "Entering a property NAME and VALUE will save"
			echo "this information to the module settings as custom"
			echo "prop values."
			echo ""
			echo "Options:"
			echo "  -d		*Update to fingerprints test list during start."
			echo "  -f		*Update fingerprints list during start."
			echo "  -l		*Save module logs and info."
			echo "  -h		*Show this message."
			echo "  -nc		Run without colours."
			echo "  -nw		Run without connecting to the web during start."
			echo "  -r		*Reset all options/settings."
			echo "  -s		*Open script settings menu."
			echo "  -t		Activate test mode."
			echo "  -u		*Perform a module update check during start."
			echo ""
			echo "Options marked with an asterisk (*) cannot be"
			echo "combined with each other."
			echo ""
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			log_handler "Exiting... Bye bye.\n\n===================="
			exit 0
		;;
	esac

	# Run options
	case "$1" in
		*d*) # Download developers prints list, for testing prints
			download_prints "Dev" "$1"
		;;
		*f*) # Update fingerprints list
			download_prints "f" "$1"
		;;
		*l*) # Save logs
			menu_logs "Collect logs" "l"
		;;
		*r*) # Reset all settings
			reset_everything "Reset all settings" "r"
		;;
		*s*) # Open settings menu
			menu_options "Script settings" "s"
		;;
		*u*) # Perform an update check
			update_check "" "$1"
		;;
	esac
fi

# Download fingerprints list and perform a module update check, if enabled
if [ "$OPTIONWEBP" == 1 ] || [ "$OPTIONWEBU" == 1 ]; then
	case "$1" in
		*d*|*f*|*u*)
			case "$1" in
				*d*|*f*) # Don't download prints
					if [ "$OPTIONWEBU" == 1 ]; then
						update_check "" "$1"
					fi
				;;
				*u*) # Don't perform the update check
					if [ "$OPTIONWEBP" == 1 ]; then
						download_prints "" "$1"
					fi
				;;
			esac
		;;
		*)
			if [ "$OPTIONWEBP" == 1 ]; then
				download_prints "" "$1"
			fi
			if [ "$OPTIONWEBU" == 1 ]; then
				update_check "" "$1"
			fi
		;;
	esac
fi

# Check if fingerprints testing is active
if [ "$(get_file_value $PRINTSLOC "PRINTSV=")" == "Dev" ]; then
	DEVPRINTS=true
fi

# ===================================================
# ==================== Main menu ====================
# ===================================================

while true
do
	orig_check
	if [ "$ORIGLOAD" == 0 ]; then
		log_handler "Original values are not loaded in propsconf_late."
		reboot_fn "The original prop values are not loaded,\n possibly due to a full reset of the module.\n\n Please reboot your device to reset." "reset-script"
	else
		if [ "$DEVPRINTS" == "true" ]; then
			INPUT=1
		else
			INPUT=""
		fi
		ACTIVE="${G} (active)${N}"
		DISABLED="${R} (disabled)${N}"
		PRINTTXT=""
		BASICTXT=""
		DEVTXT=""
		FILETXT=""
		PROPTXT=""
		CUSTTXT=""
		DELTXT=""
		if [ -z "$INPUT" ]; then
			if [ "$FINGERPRINTENB" == 0 ]; then
				PRINTTXT=$DISABLED
			elif [ "$PRINTEDIT" == 1 ]; then
				PRINTTXT=$ACTIVE
			fi
			if [ "$BASICATTEST" == 1 ]; then
				BASICTXT=$ACTIVE
			fi
			if [ "$FINGERPRINTENB" == 0 ] || [ "$PRINTEDIT" == 0 ]; then
				DEVTXT=$DISABLED
			elif [ "$DEVSIM" == 1 ] && [ "$BRANDSET" == 1 ] || [ "$NAMESET" == 1 ] || [ "$DEVICESET" == 1 ] || [ "$RELEASESET" == 1 ] || [ "$IDSET" == 1 ] || [ "$INCREMENTALSET" == 1 ] || [ "$SDKSET" == 1 ] || [ "$DISPLAYSET" == 1 ]; then
				DEVTXT=$ACTIVE
			fi
			if [ "$PROPEDIT" == 1 ]; then
				ITEMCOUNT=0
				magiskhide_props_menu "$SAFELIST" "" "count"
				magiskhide_props_menu "$TRIGGERSAFELIST" "trigger" "count"
				magiskhide_props_menu "$LATESAFELIST" "late" "count"
				if [ "$ITEMCOUNT" != 0 ]; then
					PROPTXT=$ACTIVE
				fi
			fi
			if [ "$CUSTOMEDIT" == 1 ]; then
				CUSTTXT=$ACTIVE
			fi
			if [ "$DELEDIT" == 1 ]; then
				DELTXT=$ACTIVE
			fi
			menu_header "Select an option below."
			echo ""
			if [ "$UPDATECHECK" ]; then
				echo -e "${C}$UPDATECHECK${N}"
				echo ""
				if [ "$UPDATECHECK" == "No update available." ]; then
					UPDATECHECK=""
				fi
			fi
			echo -e "${G}1${N} - Edit device fingerprint${PRINTTXT}"
			echo -e "${G}2${N} - Force BASIC key attestation${BASICTXT}" # Google once again changed their SN checks. This is no longer viable. Will remove completely in future.
			echo -e "${G}3${N} - Device simulation${DEVTXT}"
			echo -e "${G}4${N} - Edit MagiskHide props${PROPTXT}"
			echo -e "${G}5${N} - Add/edit custom props${CUSTTXT}"
			echo -e "${G}6${N} - Delete prop values${DELTXT}"
			echo -e "${G}7${N} - Script settings"
			echo -e "${G}8${N} - Collect logs"
			if [ -z "$UPDATECHECK" ]; then
				echo -e "${G}u${N} - Perform module update check"
			fi
			echo -e "${G}r${N} - Reset all options/settings"
			echo -e "${G}b${N} - Reboot device"
			echo -e "${G}e${N} - Exit"
			echo ""
			if [ "$REBOOTCHK" == 1 ]; then
				echo -e "${R}Some options/settings have been changed.${N}"
				echo -e "${R}Please reboot for them to take affect.${N}"
				echo ""
			fi
			if [ "$PRINTCHK" == 1 ]; then
				echo -e "${R}The device fingerprint has been updated.${N}"
				echo -e "${R}Please reboot to apply.${N}"
				echo ""
			fi
			echo "See the module readme or the"
			echo "support thread @ XDA for details."
			echo ""
			echo -n "Enter your desired option: "
			read -r INPUT
		fi
		case "$INPUT" in
			1) menu_change_fingerprint "Edit device fingerprint${PRINTTXT}" $CURRFINGERPRINT $ORIGFINGERPRINT $MODULEFINGERPRINT
			;;
			2) menu_force_basic "Force BASIC key attestation${BASICTXT}" # Google once again changed their SN checks. This is no longer viable. Will remove completely in future.
			;;
			3) menu_dev_sim "Device simulation${DEVTXT}"
			;;
			4) menu_magiskhide_props "MagiskHide props${PROPTXT}"
			;;
			5) menu_custom_props "Custom props${CUSTTXT}"
			;;
			6) menu_delete_props "Delete props${DELTXT}"
			;;
			7) menu_options "Script settings"
			;;
			8) menu_logs "Collect logs"
			;;
			u|U)
				if [ -z "$UPDATECHECK" ]; then
					menu_update_check "Perform module update check"
				else
					invalid_input 1 1
				fi
			;;
			r|R) reset_everything "Reset all options/settings"
			;;
			b|B) reboot_fn "Reboot device" "reboot"
			;;
			e|E) exit_fn
			;;
			*) invalid_input 1 1
			;;
		esac
	fi
done
